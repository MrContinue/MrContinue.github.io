<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MrContinue.github.io</id>
    <title>Continue的博客</title>
    <updated>2020-07-17T14:06:41.067Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MrContinue.github.io"/>
    <link rel="self" href="https://MrContinue.github.io/atom.xml"/>
    <subtitle>我从心底里爱着…你内心深处沉睡着的希望</subtitle>
    <logo>https://MrContinue.github.io/images/avatar.png</logo>
    <icon>https://MrContinue.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Continue的博客</rights>
    <entry>
        <title type="html"><![CDATA[我的OI，也许不算是故事]]></title>
        <id>https://MrContinue.github.io/post/wo-de-oiye-xu-bu-suan-shi-gu-shi/</id>
        <link href="https://MrContinue.github.io/post/wo-de-oiye-xu-bu-suan-shi-gu-shi/">
        </link>
        <updated>2020-07-17T14:00:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>あぁ このまま僕たちの声が
你我二人的呐喊

世界の端っこまで消えることなく
如若能就此贯穿至

届いたりしたらいいのにな
世界尽头 就好了呢

そしたらねぇ 二人で
如若成真的话 那我们会

どんな言葉を放とう
一起喊出怎样的话语呢

消えることない約束を
那就二人一齐

二人で「せーの」で
定下一个永不磨灭的约定吧
 

「美しい眺めだつた。」
美不胜收。
 

「かたわれ時だ。」
黄昏之时。
</code></pre>
<h2 id="一">一</h2>
<p>这篇文章没有渲染，没有插图，甚至本来还不想用标题的，但是为了方便屏幕面前的宁阅读这样的废字一堆，我觉得还是得为宁设置一些分块呢。<br>
想不出来什么标题啦，就用数字标号来命名标题吧。这里就是一啦。</p>
<h2 id="二">二</h2>
<p>对信息的兴趣应该是始于小学5年级吧。那个时候还什么都不懂啊，但是知道装B是一件很开心的事。<br>
什么事最装B？5年级的我深深思索。直到受到《黑客帝国》等影片和各方面的影响过后，就渐渐觉得，这个不同于其他科目的小东西挺有意思。<br>
现在想起来，当时对这个又有刻意的喜欢，不仅是自己本身的喜欢，还有大概就是不服输吧。<br>
想起来，现在还记得，小学3年级的时候，学校才开信息课，练金山打字。当时时我的同桌，兼好朋友（不是最好，但是关系还可以）的小H，打字比我快。我当时就特别不服。记得好像还哭过？hh，就看到信息老师表扬小H的样子，小时候的我还是很不服输的哈qwq</p>
<p>后来也不知道为什么，就开始感兴趣了。也是感觉电脑能做很多事吧。尤其是小时候，还是说长到现在，遇到要做什么PPT啊，Word要排个版啥的，老爹每次都会揽下这些活儿。有的时候我就待在旁边看，感觉老爹点了个什么，把什么圈起来了，丑丑的字体啊、排版啊，就会变成我想要的样子。<br>
太神奇了，这简直就是魔法啊有木有！！</p>
<p>再有一个就是自己从小到大在外人面前就从不是那种撒娇的软妹，自己也没想过变成这种人。说实话，甚至有点讨厌这样。当然不是讨厌这样的女生，说实话，我认为这才是真正的女生。就，单纯的想帅帅的，和别的人不一样，甚至，想成为男生。我心中的男生，应该是很勇敢的，做事也冷静，无拘无束的，更是保护女生的形象啊，我就是想成为我心中的那种形象。所以很多时候也会刻意去尝试一下常人眼中“男生专属”的事。网络上的性别全设置为男，虽然自己害怕虫子，可在学校里一旦遇到虫子可都是有尽力冲上去消灭呢，尤其是在其他女生面前，想要保护她们呢qwq 喜欢编程也有这一部分因素吧。看，我是女生，一样可以做你们眼里“男生专属”的事呢。<br>
所以甚至后来，有人甚至对我说“学信竞的都是男生，所以你就是个男的”的时候，一部分是愤怒，另一部分的心情，其实挺开心的。</p>
<p>可能很多七零八碎的理由，总之就是对这个东西有着不同于其他科目的喜欢。</p>
<h2 id="三">三</h2>
<p>后来好像是真的有点喜欢了。老爹就问我，你是不是真的喜欢这个东西嘛？喜欢吗就去报个班，试一试又没啥问题。当开始我觉得比较新奇，又比较害怕，不知道这个东西深入研究到底是怎样的。后来又想了想，的确，这个学了又没有坏处，就去报了个坑B班——tctm。不得不说，tctm确实在百毒的宣传上像发了疯一样，铺天盖地的，确实能很有效的让当时的我们这种对OI从没接触过的家庭上钩。哦，是收网，一收就一箩筐的那种。先去那里学的JS，后来考上了BS，就去学了C++。</p>
<p>怎么说，确实，人生第一次感受到了被割韭菜的感觉。但是，还是有学到一点东西。不是说tctm不教人东西，就是他的收费和他教给我的东西，不能成正比的。</p>
<h2 id="四">四</h2>
<p>6年级的时候来了BS吧，当时教我的是jzp1025。因为才正式接触OI，之前我还是个自以为scratch不错就洋洋自得的人呢。后来发现这是个新东西，所以很有认真听课。<br>
不知道为什么，总感觉老师讲课真就挺不容易的，但是又很多人在jzp1025讲课时回头玩游戏，我就觉得不应该，老师讲一阵也不容易，而且学知识那么好的事，老师也讲得挺好，所以我基本上都会回头听jzp1025讲课。除了有些时候，天性释然嘛，可能会任性一波，就，尤其后期的时候，有的时候自以为挺不错就会回头去开小差……现在想起来，真是……没开个好头呢。</p>
<p>后来jzp1025没教我了，挺不开心的。兴趣就突减了，具体原因，感兴趣就可以看看我的CSP游记，这里不放链接了，找一找也不费劲，或者是宁直接跳转到大标题“七”，那里我直接copy过来了。不是我不尊重读者宁，就，算是黑历史吧，这里明摆着写出来怪怪的，还是把这个黑历史用一句话藏在一大篇游记里面比较合适，不太会引起宁们的注意。<br>
扯远了。后来就是liaoheng教的我啊。hhh我也不知道为什么可能是脑子有病（bushi），当时我就特高冷，就，装高冷。后来别人告诉他现在认识的我和那个时候的我简直，天差地别。那个时候好多人错以为我是学霸，就以为我是那种，高冷学霸冰山型。然后在liaoheng的课上基本上就不听课，然后题的话，就。。。。不会就直接copy网上的。。。。。。。。。所以至今我的基础都不太牢。。。。。。就是因为这个原因。。。。但是怎么说，对OI还是有喜欢的，甭管宁说什么copy代码这种事肯定不算真爱，但我就还是感兴趣，挺喜欢吧。</p>
<h2 id="五">五</h2>
<p>后来正式进入BS，考竞赛，五科竞赛可以选两科。当时应该是坚定了要去学OI，但是因为自己成绩不太稳定，好的时候可以挤进全年级前20，坏的时候年级800都进不了（笑），所以决定多选一科，给自己留个后路。因为当初比较喜欢化学，但是后来自己的化学成绩又下去了，就选了感觉还不错的、平常就是要考试的副科的生物竞赛。后来没想到的是两个竞赛我都考上了，这是真的没有想到的。本来说考上一科就自足了，看来这次成绩是忽高忽低里面的高。</p>
<p>当然，后来生物上了一两节课就退了。没想到一直以来的目标yzl同学还退了物理走生物道路。听别人说他本来走物理也是全班前五这样子。哎，这大概就是大佬叭（笑）</p>
<p>其实选竞赛这件事最感动的还是父母吧。一是没有因为我是女生就觉得不能学信竞，二是当初我选了两个竞赛都是小竞赛（就是肯定不能和数理化这三门比啊，这三门都是人又多，平常受的3重视也多，生物信息基本上就是小竞赛嘛，大家心里都有点那啥数的（（（），但是父母都没有说什么，都说都说是你感兴趣就好。确实很感动。后来€€£高价收费，tctm疯狂割韭菜，父母都没有怎么抗议，就是你想学习，这是好事，爸爸妈妈绝对支持你。所以我这在方面是真的有绝对自由，挺好的qwq。</p>
<h2 id="六">六</h2>
<p>我觉得我短短一年多两年的OI之路，大致可以分为四个阶段：试探期、狂热期、退热期和重拾期（反复）。大概5<sub>6年级左右就是第一个阶段，6</sub>初一上一两个月就算是第二~三个阶段，后来，直到现在，就在第三和第四阶段反复横跳。。。。</p>
<p>试探期，前面应该讲过了。狂热期的话，就是遇到现在的教练did，和CSP比赛吧。<br>
关于did，之前一直略有耳闻。当看见本校OJ上学长们“did四海八荒第一帅”等近乎饭圈式的个签时，我是真滴很好奇。就，不仅是对这个人的外貌，还有就是这个人到底有什么魅力，把之前的学长都迷得七荤八素的（奇怪的比喻增加了.jpg）。正好did是我们平常文化信息课的老师。当时我还没见过他，第一节信息课前我就问我一个曾经被did教过的好盆友，问她did人咋样。</p>
<p>她就说，啊，挺好一人。<br>
啧，没有get到重点。<br>
啊，就，长的挺好看的。啧，就，就，反正看你个人审美吧，我觉得长得挺好的。</p>
<p>老夫心中一惊，那叫一个期待。<br>
然后did几分钟过后就进来了，然后我就真的，知道did的魅力了，人格魅力。</p>
<p>下课我把那个好盆友爆锤了一顿（bushi</p>
<p>再后来就是第一节信竞课嘛。当时已经觉得did这个人真的很NICE。包括从他做事的一些态度，对人的真诚，尤其是对学生的关心，都真的很让我佩服。我开始有点明白之前那些学长的举动了。</p>
<p>和did具体怎么熟的，可能是在文化信息课过后，我找did要更高阶的本校OJ账号，did可能就这么对我有模模糊糊的影响吧。后来自学（还是在狂热期嘛qwq）的时候，学指针，头都大了，就问did，did说不学这个。彳亍 口八，不学就不学吧。<br>
再后来，在某次文化信息课上，大家都在水cout、cin的题，那个时候我可能掌握了一点递推了叭，did就把我叫到讲台上来，给了我信竞的内部教材。那个时候我还不知道自己能不能考上信竞呢，did就这么信任我。他说你自己去学一学。我问，我要是到时候没考上信竞咋整？did就说，你放心，到时候再说，这边你不用担心。我真的，当时就有一种，非常酥服的感觉。回去发奋自学这个教材——无果。但是这还是给了当初的我一个很大的激励。<br>
再再后来，竞赛考试的结果出来了，我考上了。有天did叫我到讲台上来，问我，你觉得我们班上，没考上信竞的人当中，谁还比较可以？我就说了我们班上掌管投影仪的同学和一个教室里坐在我斜前面的同学，因为曾经听到他提过什么递推过。后来，我推荐的第一位大佬放弃了，第二位大佬是写这段文字时，最近一次考试的NO.1。看来我还是有眼光（（（小小的自负一波<br>
虽然我自己可能会AFO，但这些大佬能给BSOI增光，他们能因为我的推荐而上了更好的班，我也满足了。（为啥我总感觉自己就像狗监杨得意？？？？）</p>
<h2 id="七">七</h2>
<p>后来就是CSP吧。关于CSP的游记，写下这行字的今天我真的记不太清了，尤其是一些细节。但是幸好我在几个月前写了一篇回忆半年前CSP游记的文章，当初各种各样我真实的心情和细节，才得以被记住。这里直接copy过来了，因为我觉得这篇游记里我现在想讲的已经讲完了。</p>
<pre><code>（突然发现之前写的游记被自己删了，应该是连自己都看不下去了，那就重新写一篇咯，即便过去了半年，但是所有的事情记得还是很清楚呢qwq）

初赛
初赛前一天 2019.10.18
之前在网上下载了近8年来的初赛例题，课件、晚上都在做。还特意拿了一个小本子出来记录重点知识，背后还收集了一点自己做错的题。那个时候还不知道有洛谷这样可以线上做题的OI网站，白费了很多纸张和时间精力，但是现在想起来效果还是不错的。

初赛时知道自己考上了信竞。初赛前教练也有带把大家聚在一起，然后分发了初赛模拟卷，让大家在电脑上作答，反正不是那种很正规的，就是试试水，了解一下自己能力。

其实说实话吧，之前做的那几套初赛卷子里面一直不太敢记分数，但是有一两套记了分，大概是40~50分的样子。我自己个人感觉分数很低，然后上网上查，看到网上说“70分左右就能过'”，我：？？？？？，我自闭了。

当天晚上自己测出来的成绩大概是54分的样子，这个分数还成了我当时做过的所有初赛及模拟卷子里考得最好的一次。教练就说大概65分左右就不用担心。我：？？？？？，然后就更自闭了。

因为当时初入竞赛，学校开了很多竞赛讲座，也灌输了不少竞争激烈的例子。都说是什么“初二怎样怎样……”，又提到“什么什么班又必须怎么怎么样”，所以初赛前一天非常紧张，一直想着“要是我连初赛都过不了，那我不就完了吗。”之类的东西。

所以当天早上太阳穴痛，被强制放松，看会儿电视，下午和晚上敷敷衍衍复习了自己之前做笔记的小本子，又看了两眼之前自己做的初赛卷子。草草入睡，和平常一样失眠。

初赛当天 2019.10.19
当天去的时候很紧张，但是也很激动，毕竟这是我OI生涯的第一次正式考试。

去之前听教练说就在三教楼一楼考试，所以地形比较熟悉，没有耽误什么时间，就是找自己在哪个考场花了点时间。因为提前了一会，所以途中还拜访了每个考场里认得到的老师。

找到了自己的考场过后就掏出笔和准考证啊，和平常考试流程差不多。

监考我们的老师曾经教过我一段时间，还是认得到的，一切都是熟悉的事物，所以不是特别紧张了。

开始考试，大概浏览了一下题型、题量，和之前心里的预估差不多。
考试过程中肯定有很多原题，但是记得很清楚的就是一道填空题，关于二叉树的。因为这道题是我在某机构学习二叉树时的一道开胃题，当时还蒙对了，特高兴。后来在刷以前的初赛题的时候又刷到过，立刻做对了。但是这个时候有点紧张，忘了当初选的是C还是D了，就随便选了个。结果最后成绩出来的时候发现错了，特不甘心。

当然初赛最怕的还是补全程序和看程序写结果。我心里预估的很准，就是基础的简单一点的分能拿到，稍微难一点的就有点悬。所以有40%的难题是玄学连蒙带猜填的答案。后来发现对的还不少，嗨森qwq。

开始20多分钟就基本上写完了，空了一点怎么也想不出来的题，开始怼着补充程序题猛（发）算（呆）。
到最后觉得无可救药了，就结合上下文蒙了几个答案上去。随便在草稿纸上估了个分，有点忘了，大概估分60-吧，可能就是凉凉了吧。考前教练给我们打过气，说我们以后还有机会，这次没发挥好没事。我想着那也没办法，就只能这样了。

然后，开始发呆。
发呆发累了，双手枕头准备睡觉。
睡不着，开始看别人睡觉。。。（真的，当时我前面的人都开始打鼾了）

……

看了看手表。震惊！还有10分钟了！！
果断爬起来检查自己写的答案。
虽然一般情况下“检查”这个行动一般是无意义行动，但是今天这么重要的考试还是要认真看一看。
选择题个人感觉没有什么事，有什么事情那也没法补救。
最担心的是看程序写结果和补充程序。所以多检查了一会。我检查一般就是随便逮一道想了很久的题然后疯狂检查。

我的这次初赛，是特别神奇的一次，因为在最后发生了奇迹。
下面是本次初赛奇迹发生时我的心理过程：

诶？等等？
这道题好像错了？？
（反复计算）
诶，确实错了诶！我运气真好一看就遇到了错的题。
（长吁一口气）
等等！
（震惊！）
这道题以后的题我好像都是根据这道题的答案推出来的！
妈耶，凉凉。
（看了看手表还剩5分钟）
（发疯修改）
啊……终于……
我可能就只能做到这样了吧……听天由命，我也不知道改对没有，也不知道原来的答案对不对……
（看手表，此时还剩1分半）
（心脏狂跳）
（监考老师背景音：同学们检查自己的名字写好没有哈……）
……
（监考老师背景音：收卷了，不要写了哈）
……

我最后修改的一批题的分数，足以让我从60分到68+。
但是如果不行的话，扣掉的分数绝对致命。
应该还是有救的吧。我这样想。

……

既然收卷了，就不去管它啦。
初赛的时候还没有在信竞班里结识好朋友，自己收拾东西又很慢，收完背包过后从教室出来，差不多所有人都走完了。好朋友在等我，爱你qwq。
然后去看了一眼老师们，看到了曾经教过我的老师温暖的微笑，真幸福啊。

和好朋友出来的时候碰见培训机构宣传，宣传的小姐姐惨遭我们等逗比怼。
我们路过的时候，前面的男生还在很皮的边走边说：“你看你这个宣传资料，现在都没有NOIP啦，是CSP，记得改哦。”
小姐姐尴尬一笑，转而向我和我的好朋友推荐她的机构。
她可能以为女生更好说话一点，但是你哥我不是普通女生，爷不是那种羞涩的那种兔兔，你爷就是你爷。
“啊，你们考的怎么样啊？”
闺蜜正想说话，我笑道：
“不怎么样，很不怎么样，我都凉了。”
很明显，小姐姐并不知道自己迎来的是这样的答案，她愣了一下，很快又露出尴尬而不失礼节的微笑，准备再次开始宣传。
But now，我和我的好朋友已 经 溜 了，给她留下了一个帅气而仓促的背影。（笑）

初赛in end
晚上就陆陆续续有初赛答案出来了。当时还不愿意对答案。因为从小到大，我对了答案过后总是有不太好的结果。

就以平常来看，要是对了答案出来结果不错，那么我往往会在一些古怪的地方扣分。比如，忘了某一步啊，书写不标准啊，最后的实际结果往往和预想的有极大差距。我爹曾直言：你自己对答案估出来的分不算数，一般要减上20多分才离实际分数差不多。这不是夸张句，真的是这样。
要是对了答案估出来的分不好，那就是真的不好，往往会先伤心一波，等拿到卷子了再伤心一波。

所以，当时我并没有对答案。
但是！（转折）我还是没有忍住好奇心，看了看我最后5分钟里改那的几道题。

……
……
wsl我对了！！！！

我：&amp;Grh76TGTu&amp;*(667h%ryg&amp;￥%……7r！！！

真的，就是那种无比酸爽的感觉。就是心里悬着的石头突然猛烈的冲向地面，引发了地（大）震（吼）、海（大）啸（叫）等多种自（疯）然（子）灾（行）害（为）。

当时我就觉得非常、非常开心了。

最后出来的成绩是72分，听教练说68左右就能过。我看了一下，如果我最后没有改那一道题，那我基本上就是卡线过，甚至过不了。But，who care？反正我已经过了。

wslwsl。那天我下楼都是跳着下的，作业写的字都是飘的。

这也算为我的OI之路开了一个好头吧qwq

复赛
复赛前的很多天 2019.10.xx~2019.11.24
知道了本次机试我们学校主办，学校还在非常显眼的地方拉了横幅，考试是在熟悉的环境里，非常开心。

在复赛之前自己先干了一些事情。比如水了水往年的T1、T2，学了学贪心（没错我复赛之前还不会贪心，其实现在也不会，浓雾），水了水模拟练习，看了看往年例题题解。

在复赛之前老师把我们拉在一起集训了一周左右吧，周末不休，每天晚自习都去机房，所以我（短暂的）记住了很多很多东西。

其实复赛之前我自己心里就是是很没底气的。刷了以往的NOIP试题过后就更是如此。

但与其说是没底气，只不过是很清楚自己的水平拿不了1=，就和教练说的一样，我现在考NOIP，就是考着玩。经过一些NOIP题目的历练，我一般能比较快的做出T1，有些难的T2就开始犯晕，水题的时候基本上就没考虑过T3、T4。

教练本来给我们的计划是，上去先把T1、T2水了，然后T3、T4骗点分，1=轻松到手。

但是当时我还是一个递推递归都不会的伪OIer，但是教练在我们临时集训的短短几天，不到一周的时间里，就教给了我们递归、递推、贪心、DFS、BFS以及搜索很多的例题讲解。这真的是一个很高的效率，但是我总感觉我无法像教练规划的那样顺利获得1=。因为集训的进度拉得很快，所以当初我的DFS代码是修改了很久才对的，BFS代码还是直接copy的教练PPT里的代码。递归递推以前在机构里学习过，所以问题就不大。至于贪心，我现在都没有怎么搞懂。

所以我的心里大概知道自己的水平差不多就是2=里的中下等水平。我自己估摸着，自己在考场上应该是T1秒，T2得大部分分，T3得小部分分，T4根本碰不了。

最后的成绩证明，我自己还是很清楚自己真实实力的。

复赛前一天 2019.11.25
复赛前一天，下午体训。去操场的途中路过机房（其实并不顺路，只是专门为了去看看机房的布置），突然被教练喊住，并让我在某个机房等他。
在这个机房里，许多身着陌生校服的人正在调试机子。讲台上有我们信竞班里的同班同学，大家尴尬的站在一起。

因为我们就是本学校的人，所以对调机子这件事情比较佛系。只是我比较担心一件事情。我平常竞赛课坐的位置上键盘的Backspace键有点容易被卡在键盘里，有的时候它会趁你不注意就删你一大段程序，并且把这个被键盘卡住的玩意儿搞出来还是需要一点时间。我有点担心那个键盘的问题。

不一会儿教练来了，递给了我们每人一张纸，上面印着考试的基本注意事项。这个反正明天也要发的，所以并没有什么问题。

教练特别强调，这次的机试所有的cpp文件就直接放在C盘里，不要单独建文件夹。随后又叫我们去通知其他人。

憨憨的我先跑到体训集合地向老师请了一会假，去教学楼的路上又遇见几个同学，随口问了问就跑了三楼，累的像条狗，最后通知到位了。体训那边也差不多进行了20多分钟了。

总之对明天是很期待的，听说比赛不仅有矿泉水，还有小面包吃。

复赛前一天，日常失眠。

复赛当天 2019.11.26
到达学校的时候已经是卡点进了，门口本来还有人在发什么本子，管也没管就飞冲进去了。

结果到达考场那里的时候大家都堆在门口，门口有铁栏杆和保安拦着，大家就争相去看自己的考号和考场。
因为当时附近有很多认得到的的同学，所以没费什么劲儿就知道了自己的考号和考场。我是在3考场的。
挺紧张的，认得到的同学们就开始聊天。记得最深的是当时有lmpy大佬，我一出楼梯口他就看见我了，并大声的叫住了我，简单的告诉了我相关的情况，后来看到考场过后他也一直在和我们聊天，多亏了他，我的紧张也好了一点点。
当时大家就开始讨论教练去哪里了，我们觉得他一定是去避嫌了，并且大家一致约定要是看到教练了，千万不要叫他，不然难免让人产生误解。后来证明，我们的约定是很有必要的。

途中的趣闻就是门口的一个矮矮胖胖的小朋友指着身边比他更矮的瘦瘦小朋友大声说：“大家看这里有个五年级的小学生！”我们就笑着问他，你也不还是小学生吗？结果他尴尬的回答：“我也是啊，但是我是小学六年级的诶！”让我想起了我的六年级，虽然也是不久之前，却感觉像过去了很久。最重要的，大概就是从儿童慢慢步入少年的过程吧。

过了大概10分钟左右吧，门开了，大家就争相跑到自己考场门口，把自己的包放在门口。不知道其他考场是不是一样，在蜂拥而入，本考场的老师并不及时的拦住了部分人群，其中就包括动作极慢的我。简单观察了一下，除了每个座位之间有薄薄的泡沫隔板以外，其他和平常没有什么不同。这个考场是某次教练出差时大家聚在一起打游戏的地方。回想起来那真是一个刺激的夜晚啊（车车，好快的车车！[大雾]）

说来巧合，这次复赛监考我的，就是初赛的那个曾经教过我的老师。实话实说，当时他教我的时候，我对他是比较不满的，可能是因为他的脾气有点不太好，也有可能是因为我太喜欢上一个老师。毕竟，当你的老师从高高帅帅脾气好变成了高高胖胖脾气差，十个人应该有七个人都会不太适应吧？当初我在他的班上就是属于做的题多（很明显，那些题有部分是抄的），会的东西多（只是比一部分人多一点），但是特别傲娇，特别高冷的那种（事实上我不是这种人，相信你从我的文笔里也看出来了）。所以当时留给他的印象应该是比较深的。

但是很快我就找到了我的位置，是老师告诉我的，他还是有暗中帮助我的。我坐的位置是一列的最前面，要更衣啊，要观察门口情况啊，都比较方便。

当时在猛烈争执的是我旁边的座位。开始是一个瘦的能见到骨头的男生坐在上面，后来又有一个高高的男生过来争执，说这是他的座位。我承认，后来的这个男生长的挺好看的（花痴羞耻），虽然争执的时候我也插不上嘴，但是暗地里还是想后来的男生坐过来。
最终，我的身边坐的是那个好看的小哥哥（花痴脸红）。当然不是因为他长得好看，是因为之前的男生看错考号了。

开始考试之前检查C盘的状态，记得教练说过要是你自己看完了，你就找监考老师，装憨，让他帮你看看调对了没有，这样比较保险。所以我就憨憨的叫了老师过来看，老师检查了一下是对的就走了。
这个时候旁边的小哥哥一头忙碌，他是真的没搞懂。于是我在线指导了一下，老师也过来看了一下，最后还是搞对了，小哥哥非常有礼貌的回了一句“谢谢”。啊怎么长的好看的人声音也这么好听啊www（花痴脸红），偷偷看了眼，他不是我们中学的，貌似姓刘，但是准考证一眼就晃过去了，也不知道到底别人是不是姓刘。

然后开始考试。

T1，看到我就笑了，string秒的，所有样例过了。

T2，比较清楚怎么做的，大概就是一个结构体数组，开始的时候觉得很简单，就随便敲的，但是后来发现样例一直过不了，就搁那儿一直调，最后两个小样例过了，大样例炸了。

T3，很认真的花了时间手撸样例，打了一堆工整的草稿（平常我的草稿绝对狂野风，但是今天心情比较平静，又有喜欢的太阳，又很舒适的理清了思路，旁边还有好看的小哥哥，酥服），理清了题目，大概明白就是像股市一样的操作，但是不太会写，就只骗了T=1的分。

T4，读了下题，觉得应该是图或者树之类的操作，还没学就没管了。
剩下的时间都在调T2和发呆。

中途发了矿泉水，莫得小面包（生气状）。那瓶没喝完回去被当做珍宝一样怎么都舍不得喝，空瓶子也舍不得扔。最后它在其他矿泉水的混淆视听中被丢掉了。

整T2的时候教练进了我们考场和监考老师问了几句，顺便看了几眼。我坐在离门最近的位置，看到他刚想条件反射的叫一声，结果马上回忆起来大家在考场门前的约定，并且教练用眼神也示意我千万不要叫他。于是乎我到嘴边的“d老师！”就变成了口水被我吞进了肚子里。
现在想起来可真是惊险啊，真的就差一点点吼出来。。。

考试过程中最担心的就是freopen写对没有，特别害怕把r和w写反导致抱灵。检查了很多遍，最后还是没有错。考试最后10分钟的时候去了freopen的注释，反复保存cpp文件。

最后交卷的时候已经比较不耐烦了，因为根本做不出来了。很轻松的离开了座位，去拿自己的背包。那天的草稿纸、被揉的都要烂掉的比赛注意事项、准考证，现在都静静地压在我的桌子底下。

怎么说呢，就和自己预估的差不多吧。

复赛in end
复赛结束出来，爹来接我，我就如是说考得一般，也就那样。
当时其实是比较悲观的，以为自己连3=都没有，事实上，T1过了的都有奖。

最后的分出来，2=，140=100+10+30+0。玄学，玄学。
大家大部分也没有1=，基本都是2=。但有一位大佬以250的美妙分数得到了1=，真是tql！%%%%

开始以为NOIP死了，没想到成为绝版的竟然是CSP。这段记忆我已经好好珍藏了。

OI魔芋，奥利给！
</code></pre>
<h2 id="八">八</h2>
<p>这一段就是悲伤的故事啦，也正是这篇文章会出现的原因——AFO。</p>
<p>前面有提到过，我在初期的OI学习中，就有“不会的题就copy”的致命的、最罪恶的恶习。这不仅导致了我基础不牢，而且导致了我开始安于copy代码后AC的享乐。即使到了后来，真正进入OI学习了，也会有copy的时候。紧接着，就越来越慌了。<br>
自己copy多了赶不上大家的进度，就有了不会做的题，有了不会做的题，为了赶上大家的进度，又会copy。这样的恶性循环，可能就是我AFO的主要原因之一吧。</p>
<p>我也不是很想提很多关于我的事，但如果屏幕前的宁还是初学，请一定记住要自己努力。曾经有很多人也这样给我说过，我还是没这么做，所以希望宁不要成为我（笑）</p>
<p>接下来讲点开心的，来介绍我的好朋友们吧！！qwq</p>
<h2 id="九">九</h2>
<p>排名啥的，看宁怎么看吧，反正我是觉得没先后。</p>
<h3 id="gmq">GMQ</h3>
<p>GMQ大佬是我的OI同桌啦。他是29班的，我是28班的。据他所说，我们最初的交流，当时还没见过面。他在校内OJ上发了个求助帖，一会儿陌生的我就给他私信了代码。至于这件事，我一直告诉他我不记得了。我是真的不记得有过这么一件事，可能是当时太乐于助人，帮了就忘了吧。后来上了信竞，我们成了同桌。要问后来我们怎么熟起来的，那是真的记不着了。我也问过他，他也记不着啦，就只知道现在我们关系好，就像顺理应当的，就过来了。</p>
<p>当初认为他就是一个普通男生，后来渐渐知道他喜欢飞机，民航，这方面很有了解，还画过很多飞机。再后来，就退役这几个月吧，才知道了他的一些D级人员知道了会被物理消除记忆的属性，我怀疑他可能不会同意我把它写在公众可见的博客里，所以还是别说了，虽然可能会因此少很多可写的——因为就是因为这个后来我们之间的关系开始有一点奇怪，但绝对不是什么恋爱啊这类的，绝对扯不上半点关系，提前说一下别想歪了（（（ 就，害，反正就是不太正常的友谊，但归根结底还是友谊。就真诚的友谊。</p>
<p>总之，真的还是很幸运能遇见这样一个好朋友。愿意提前到了机房过后先开你的电脑；愿意在你期末考试以后等你半个小时；愿意和你分享自己不太愿意告诉别人的事，我觉得这真是，非常非常好的事情呢。谢谢你啦qwq</p>
<h3 id="lmpp">lmpp</h3>
<p>（lmpp真名是lmpy啦qwq）<br>
由于lmpp大佬（抱歉，总是忍不住加大佬呢，但是宁好像不太愿意？我尽力QAQ）比较活跃，曾经遭受过一些同学的不太喜欢或者是直接被怼、对线。老实人u1s1，当初我对lmpp的印象也不太好，感觉。。。有点闹腾。很强，但是就。。。。害。。。。。<br>
但是（强调音），再后来，记得最深的是写图论总结的时候，我无数次在lmpp看B站最开心的时候打断他（当然，这是他本人的吐槽），他却还是（在骂骂咧咧过后）告诉我这个是怎样的，那个是怎样的。就，很感动。我想如果是我，有lmpp这样的实力，在那个时候，真不一定会理我这个菜鸡。<br>
包括他看了我的CSP游记过后，说什么“当时我都不知道我哪里帮你缓解了压力的”，但是我想说，lmpp，宁真的有或多或少的温暖到，感动到，帮助到我，或者其他人。虽然宁可能不知道，但是这些事已经足够让我记住了。最后，虽然宁不喜欢，但是。。。。</p>
<p>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCOrz！！！</p>
<h3 id="dyn">DYN</h3>
<p>谔谔，DYN大佬是怎么认识的呢？我深深思索，大概是没有具体时候了吧。就只记得当初在早培的时候，DYN大佬就是人群中最亮的那颗星。<s>反正他撩撩物理纯情高一男老师是VAN全没有问题的，这是当时我的印象</s>后来怎么认识的？？？我真的忘了。要是宁本人看到这里想补充给我说吧orz。<br>
记得的是疫情期间在家学习的时候宁问我有限硬币和无限硬币问题有什么区别（还是怎么转化他们来着？？我又忘了orz），当时我记得我咕了好久，好像几个小时过后才会吧。因为可能写得比较长（更有可能是因为咕咕咕了半天终于回了），宁当时的情绪好像比较激动（擦汗）。那以后宁又问过我一次问题。<br>
后来网课要结束了，要开学了，宁在晚上11:10突然找到我，问我有没有网课期间所有的作业答案，因为宁之前的作业全都没保存，现在老师又要要。于是我用着我1.00Hz的老爷机给宁发文件，直到11:40。在那之后我果然被爸妈骂了。。。。但是宁给我B站上所有的视频都三连了，我觉得还是值得qwq</p>
<p>一直觉得宁是一个认真能认真下来，皮能皮出天际的<s>老二刺猿</s>人。可能平常有很多点点滴滴，让我感觉到宁是一个思想先进（？），对人很体贴的人呢qwq<br>
宁乐观的心态，还有宁平常给我们带来的欢乐，我都对此感到非常的愉悦。谢谢宁的鼓励和陪伴呢qwq</p>
<h3 id="hrx-xyy">HRX &amp; XYY</h3>
<p>宁们和我，是现在OI里唯三的女生啦。宁们总是遇到了我会亲热的围上来，真的让我感到了让人感动的友谊的氛围。我们的友谊已经跨越了班级，不管什么时候，遇到了就会真诚的等待彼此，帮助彼此。尤其是在没收拾找不到饭卡的时候，二位是怎么随意让我白嫖的，我真的感激不尽。我们总是有好多好多的想交流，有好多好多的想开心的分享。哦哦，老H发明的，说了“谢谢”、“对不起”什么的，名字就会倒过来。不愧是eunitnoC呢（滑稽）</p>
<h3 id="txy">TXY</h3>
<p>之前和TXY大佬并不熟呢，就只知道那个永远的“Fly_Funny”（滑稽飘过）就是大佬啦。在这里特别提到是因为当我特别丧的时候，TXY大佬一个人鼓励了我。可能说烂了，但是我就是这样，要是宁在我特别不好的时候帮助了我，我会一直记住它的！总之就是特别特别感谢TXY大佬的鼓励，真的是一个超级超级好的人呢！！</p>
<h3 id="lyx">LYX</h3>
<p>我的初中同学（前同桌）。数学超好的大佬哦qwq。<br>
为什么每次看到你都会有一种安全和幸福的感觉呢？是因为你的勇敢和果断，还是因为你有那么多我想有但是却没有的特质，让你成为了一个“看着就会让人开心的人”呢？<br>
不管啦，反正你就是我的好朋友，初中最好的好朋友，虽然你可能不会这么想。</p>
<h3 id="wxy">WXY</h3>
<p>WXY同学不是OIer啦。是我的老婆。或者按照大多数人的说法，是闺蜜哒。在小学的时候我们无话不谈，如今到了不同中学，她却还是一如既往地鼓励我，支持我。我始终相信友谊这个东西，WXY的功劳，真是，大得不得了呢qwq<br>
同时我们还是彼此的“护盾”。她说我是她的“男朋友”，以此推脱可恶的追求者；我说她是我的“老婆”，以此一刀斩断其他人对我的闲言碎语。总之，我很喜欢这种美好的关系。希望我们是永远的朋友哦，嘻嘻qwq</p>
<h3 id="更多">更多</h3>
<p>不是因为宁们没有怎么帮助我而被写在“更多”一栏里面，而是因为这个美好的世界对我真的太好了，宁们这么多人都那么乐于帮助我这个无关紧要的人。宁们帮助我的事，我真的都记得牢牢的。宁们都是超级超级超级超级的大好人，真的！！！！</p>
<p>宁们都是：<strong>WJY、DBH、YJ、BLW（SCX）、SCQ（HCQ）、HH（MZH）、CY（YHK）</strong><br>
还有我不认识的大佬们，谢谢宁们！！！！！！！！！！</p>
<h2 id="十致谢">十：致谢</h2>
<p>在学OI的路上，首先真的要感谢我的老爹老妈。<br>
他们从不会在学习上约束我什么，从来像其他有些家长那样没有质疑我学OI的前途或者是钱途，也没有像封建主义家庭一样认为女生不能学OI。他们开放包容，提供所有的帮助给我。<br>
他们不是势利派，他们注重我的品德教育，他们关心我的身体，关心我的心理。他们想尽一切，都是为了让我过的好一点。他们也许不是完美的家长，但真的是超级好、超级尽责，真正是家长的家长。</p>
<p>然后就是did。<br>
did，那个总是告诉我们“不要睡太晚”却在晚上11:30都会回答你学习上疑惑的好教练。经典的“三秒回滚，我查监控”这种事我就不用提了吧？真的是一个关心学生，真正有师德的老师。他就像我们的大朋友，知道我们在想什么，还会迁就我们，和我们玩梗。学OI这1年，我真的认为是很快乐的，就是因为和did，和有趣的同学在一起，学自己喜欢的东西。</p>
<p>OI的同学啥的，讲了那么多。总之就是很感谢，所有对我的关心、鼓励和帮助。真的，发自内心的感谢。</p>
<p>所有鼓励过我的人，我会好好加油的！<br>
所有给过我希望的人，我会好好继续下去的！</p>
<h2 id="">。</h2>
<p>2020年7月17日22:06:08，然后就没了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整理】图论模板题及知识点汇总（详细稿，已完结）]]></title>
        <id>https://MrContinue.github.io/post/zheng-li-tu-lun-mo-ban-ti-ji-zhi-shi-dian-hui-zong-di-er-gao-run-se-zhong/</id>
        <link href="https://MrContinue.github.io/post/zheng-li-tu-lun-mo-ban-ti-ji-zhi-shi-dian-hui-zong-di-er-gao-run-se-zhong/">
        </link>
        <updated>2020-07-14T14:16:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="特别特别感谢">特别特别感谢：</h2>
<p><a href="https://www.luogu.com.cn/blog/160839/"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>m</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">lmpp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span></a>大佬<strong>牺牲自己宝贵时间，为我没有脾气的耐心讲解。</strong></p>
<p><a href="https://www.luogu.com.cn/user/77609"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>e</mi><mi>y</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">BeyondHeaven</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span></a>大佬，<strong>无偿帮我康博客，甚至和我这个陌生的蒟蒻分享自己的故事，带给了我知识和温暖。真的、真的非常谢谢宁！<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></strong></p>
<p><a href="https://www.luogu.com.cn/user/334392"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Fly</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>_<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mi>n</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Funny</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></a>大佬，<strong>理会了一个无关紧要的人发的丧气话，并且带给了她把这篇博文更完的动力</strong>。</p>
<p>真的很感谢我的教练<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">did</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，他的宽容友爱和超一流的教学水准不仅让我迈上了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">OI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>的正轨，更让我感受到了朋友的温暖。</p>
<p>还有很多很多好朋友帮助了我（详见友链），真的非常感谢你们！</p>
<p>没有你们就没有这篇博客，我也会比现在蒻上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>倍。</p>
<hr>
<h2 id="提示">提示：</h2>
<p><strong>本博客还并没有做到完全是自己总结的概念，但是我已经正在努力填坑了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mi>A</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">QAQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">A</span><span class="mord mathdefault">Q</span></span></span></span>。</strong></p>
<p>本文将以尽量朴（全）实（口）无（水）华（话）的语言和自己的一些奇奇怪怪的想法，为您呈现一个我眼中的图论世界。</p>
<p>在我自己掌握特别不好的题目/知识点旁会加以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 的标记。</p>
<p><strong>所有题号以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>S</mi><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">BSOJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>为准</strong>。所有题目已经附上了题干和样例数据。题目链接我也正在尽量引用公开的大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">OJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>上的题目，方便大家做题学习。<strong>注意！有些题的代码可能和附上的链接题目不能吻合，但题目的思路一定都是一致的，只是细节上的不同，具体代码对应的题干还是看我附在代码前的题干！</strong></p>
<p>有什么错误纰漏的直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">QQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">Q</span></span></span></span>+洛谷私信+讨论区留言，我真的超级需要您的反馈的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>。</p>
<p>希望能您能从这份清单中找到您的一些知识漏洞并把它们补起来！</p>
<hr>
<h2 id="更新信息">更新信息</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.3.29</mn></mrow><annotation encoding="application/x-tex">2020.3.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">.</span><span class="mord">2</span><span class="mord">9</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.0</mn></mrow><annotation encoding="application/x-tex">1.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本</strong>，开始新的篇章。知识点记录至拓扑排序模板题。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.3.30</mn></mrow><annotation encoding="application/x-tex">2020.3.30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">.</span><span class="mord">3</span><span class="mord">0</span></span></span></span> &amp;&amp; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.3.31</mn></mrow><annotation encoding="application/x-tex">2020.3.31</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">.</span><span class="mord">3</span><span class="mord">1</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.0</mn></mrow><annotation encoding="application/x-tex">2.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本</strong>，爆肝完所有知识点。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.6</mn></mrow><annotation encoding="application/x-tex">2020.5.6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">6</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.0</mn></mrow><annotation encoding="application/x-tex">2.5.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本</strong>，在自己的反复体会和阅读学习后进行了对<strong>文本效果</strong>、<strong>知识内容</strong>方面修复部分问题。拓扑排序部分已删去死板概念，换为自己理解。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.7</mn></mrow><annotation encoding="application/x-tex">2020.5.7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">7</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.1</mn></mrow><annotation encoding="application/x-tex">2.5.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">1</span></span></span></span>版本</strong>，书面上已经总结完了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法，博客上还没整完。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.8</mn></mrow><annotation encoding="application/x-tex">2020.5.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">8</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.2</mn></mrow><annotation encoding="application/x-tex">2.5.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span></span></span></span>版本</strong>，书面上已经总结完了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>算法，博客上还没整完。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.10</mn></mrow><annotation encoding="application/x-tex">2020.5.10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.3</mn></mrow><annotation encoding="application/x-tex">2.5.3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">3</span></span></span></span>版本</strong>，书面上已经总结完了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法，博客上还没整完。（发现一直以来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>大神的名字都写错了，真的对不起了呜呜呜呜）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.11</mn></mrow><annotation encoding="application/x-tex">2020.5.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.4</mn></mrow><annotation encoding="application/x-tex">2.5.4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">4</span></span></span></span>版本</strong>，书面上已总结了一丢丢<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>，未完待续。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.5.12</mn></mrow><annotation encoding="application/x-tex">2020.5.12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.4.5</mn></mrow><annotation encoding="application/x-tex">2.5.4.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">4</span><span class="mord">.</span><span class="mord">5</span></span></span></span>版本</strong>，乌龟速度更进<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>，废话一堆堆，未（我）完（想）待（烂）续（尾）。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.6.8</mn></mrow><annotation encoding="application/x-tex">2020.6.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">8</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.5</mn></mrow><annotation encoding="application/x-tex">2.5.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">5</span></span></span></span>版本</strong>，把之前的数字和字母做了优化，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>开始更新。<s>不要问我为什么拖了这么久才又开始更。别问，问就是半期考试。不要问我半期考得怎么样。别问，问就是全班垫底（bushi）</s></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.6.9</mn></mrow><annotation encoding="application/x-tex">2020.6.9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">9</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.5.6</mn></mrow><annotation encoding="application/x-tex">2.5.6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">6</span></span></span></span>版本</strong>，书面上已经总结完了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>的基本概念，开始更新割点之类的概念。总结上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>还没更完，发给了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">did</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>康康，<s>我怀疑他不会回我。</s></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.7.11</mn></mrow><annotation encoding="application/x-tex">2020.7.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.6.0</mn></mrow><annotation encoding="application/x-tex">2.6.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本</strong>，直接到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.6</mn></mrow><annotation encoding="application/x-tex">2.6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span></span></span></span>版本是因为之前陆陆续续有在做一些修改和删减，大概可以算是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.6.0</mn></mrow><annotation encoding="application/x-tex">2.6.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本了叭？……（小声）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.7.12</mn></mrow><annotation encoding="application/x-tex">2020.7.12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.6.0</mn></mrow><annotation encoding="application/x-tex">2.6.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span></span></span></span>版本</strong>，准备放弃了，大概是和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">OI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>没有缘分了。在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>u</mi><mi>o</mi><mi>g</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">luogu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">u</span></span></span></span>上发表了一篇丧丧的文章吧，应该没有人会理我的，希望负能量没有影响到大家<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">orz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020.7.14</mn></mrow><annotation encoding="application/x-tex">2020.7.14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span></span></span></span> <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.6.0.1</mn></mrow><annotation encoding="application/x-tex">2.6.0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span></span></span></span>版本</strong>，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>u</mi><mi>o</mi><mi>g</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">luogu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">u</span></span></span></span>上丧气的文章，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>o</mi><mi>x</mi><mi>u</mi><mi>a</mi><mi>n</mi><mi>y</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">taoxuanyu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">u</span></span></span></span>大佬鼓励了我，挺好，所以还是决定在这篇文章不要烂尾，至少题目的链接啊，题干啥的还是要放一放，知识点看了一下，应该也是没有问题的。想了想还是给丧气话加上了渲染（（（算是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">OI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>留下自己一个完整的脚印吧。</p>
<hr>
<h2 id="备忘录-to-do-list">备忘录-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">TO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">DO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">List</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></h2>
<ul>
<li>
<p><s>把原题目链接换成大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">OJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>的题目链接</s></p>
</li>
<li>
<p><s>附上题目的题干和样例数据</s></p>
</li>
<li>
<p>（缓慢任务）删掉一些毫无营养的口水话，但是不能影响详细、搞笑（？）的风格</p>
</li>
</ul>
<hr>
<h2 id="拓扑排序">拓扑排序：</h2>
<h3 id="什么是拓扑排序">什么是拓扑排序？</h3>
<p>拓扑排序，通过名字里的“排序”，我们自然知道了它的功能——排序。<br>
那么，它怎样排序的？又是为谁排序的？</p>
<h4 id="拓扑排序的简单规则">拓扑排序的简单规则</h4>
<p>“排序”，一个多么简单的概念。在你的脑海里，“排序”是否具有以下特征呢？</p>
<ul>
<li>一堆数据</li>
<li>一些规则</li>
</ul>
<p>正如大多数排序一样，拓扑排序也具有以上的简单特征。</p>
<h5 id="从一堆数据开始思考">从“一堆数据”开始思考</h5>
<p>不妨想想，作为一个<strong>图</strong>工作的排序，怎样才能构造出“一堆”数据呢？<br>
答案是明显的，<strong>我们应该将图中的每一个节点取出，形成我们排序所需的一堆数据</strong>。<br>
可是我们怎么选择取出的节点呢？真就毫无目标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">rand()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>函数随机整一个？</p>
<p>如果想到了这点，我们就可以开始考虑拓扑排序的<strong>规则</strong>。</p>
<h5 id="怎样用一些规则排序">怎样用“一些规则”排序？</h5>
<p>所谓规则，就是一个算法进行操作的方法。<br>
对于拓扑排序来说，它的操作方法便是如下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>步：</p>
<ol>
<li>寻找一个入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的点（为什么？<s>这就是“规则”，定死了的，不然你咋不问我为啥1+1=2</s>人为规定的，不然怎么开始排序？？？）</li>
<li>取出这个点，随之被删除的还有和这个点所有直接相连的边</li>
<li>在剩下的节点中重复第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>步，直至所有节点被取出</li>
</ol>
<h4 id="我们对谁使用拓扑排序-谁身上才能使用拓扑排序">我们对谁使用拓扑排序？/ 谁身上才能使用拓扑排序？</h4>
<p>我们对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DAG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault">G</span></span></span></span>——即：<strong>有向无环图</strong>使用拓扑排序。</p>
<h4 id="为什么我们只能对dag进行拓扑排序">为什么我们只能对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DAG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault">G</span></span></span></span>进行拓扑排序？</h4>
<p>通过刚刚的过程分析，我们可以轻易地发现一个问题：<strong>如果当前的节点没有全部被取出，但却已经发现不了入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的节点，那么我们就不能愉快的继续拓扑排序了</strong>。</p>
<p>不妨思考一下为什么会出现这种<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">bug</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>。<br>
一切的证据都指向<strong>有向有环图</strong>。（无向就不说了，咋整都是个环）</p>
<p>为啥？我们先来看看下图——一个有向有环图，来模拟一下拓扑排序的过程：<br>
<img src="https://MrContinue.github.io/post-images/1588862342176.png" alt="" loading="lazy"><br>
第一步，我们找出了入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的节点①，并且将它和它相关联的边取出。<br>
于是乎，现在的图是这样的：<br>
<img src="https://MrContinue.github.io/post-images/1588862416195.png" alt="" loading="lazy"><br>
这时我们可以发现一个有趣的事情。由于②、③。④三个点形成了一个环，所以现在图中<strong>没有入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的点</strong>。<br>
<img src="https://MrContinue.github.io/post-images/1588862552301.png" alt="" loading="lazy"><br>
所以此时就会出现<strong>无法继续进行拓扑排序</strong>的问题。而这一切正是印证了<strong>拓扑排序只能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DAG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault">G</span></span></span></span>图里进行操作</strong>的事实。</p>
<h3 id="关于拓扑排序的应用">关于拓扑排序的应用</h3>
<p>拓扑排序一般很少有单独针对该知识点的题，但是在<strong>关键路径</strong>和平常的其他例题的辅助操作中却发挥着重要作用。所以掌握好拓扑排序是很重要的事情。</p>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1462"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1462</mn></mrow><annotation encoding="application/x-tex">1462</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">6</span><span class="mord">2</span></span></span></span> 拓扑排序</a>（这题实在太水了，大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">OJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>上根本找不到，只好把题干和样例附在这里，提交就随缘吧（（（）</p>
<h4 id="description"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>对一个有向图(Directed Acyclic Graph简称DAG) G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若 ∈E(G)，则u在线性序列中出现在v之前。
若图中存在有向环，则不可能使顶点满足拓扑次序。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://oj.bashu.com.cn/pub/images/2874.jpg" alt="" loading="lazy"></figure>
<h4 id="input"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第1行：2个空格分开的整数n和m，分别表示图的顶点数和边数。
第2..m+1行：每行2个空格分开的整数i，j，i表示一条边的起点，j表示终点。
</code></pre>
<h4 id="output"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>拓扑序，顶点从1开始编号，如果有多个拓扑序，则顶点编号小的优先输出。
有环输出：no solution
</code></pre>
<h4 id="sample-input"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<p>【样例输入1】</p>
<pre><code>4 4
1 3
1 4
2 3
2 4
</code></pre>
<p>【样例输入2】</p>
<pre><code>4 4
1 2
2 3
3 4
4 1
</code></pre>
<h4 id="sample-output"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<p>【样例输出1】</p>
<pre><code>1 2 3 4
</code></pre>
<p>【样例输出2】</p>
<pre><code>no solution
</code></pre>
<h4 id="hint"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Hint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></h4>
<p>【数据范围】</p>
<pre><code>1≤n≤200
1≤m≤20000
</code></pre>
<p><strong>本代码按字典序输出的部分：</strong></p>
<pre><code class="language-cpp">int j=1; //从第一个点开始查找
while(j&lt;=n&amp;&amp;bein[j])
	j++; //统计入度为零的节点
//由于-1的bool值也视作真，所以可以标记为-1
if(j&gt;n) return 0; //如果统计的节点超出了范围n，说明这个图有环
sum[++top]=j; //拓扑序列答案数组统计新答案
</code></pre>
<pre><code class="language-cpp">//本代码由邻接矩阵实现，按字典序输出，复杂度O(n^2)

#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 205
using namespace std;

int bein[maxn]; //bein[i]表示节点i的入度
int a[maxn][maxn]; //邻接矩阵存图
int sum[maxn],top; //拓扑序列答案数组
int n,m;

int TS()
{
	for(int i=1;i&lt;=n;i++)
	{
		int j=1; //从第一个点开始查找
		while(j&lt;=n&amp;&amp;bein[j])
			j++; //统计入度为零的节点
        //由于-1的bool值也视作真，所以可以标记为-1
		if(j&gt;n) return 0; //如果统计的节点超出了范围n，说明这个图有环
		sum[++top]=j; //拓扑序列答案数组统计新答案，储存已取出的点
		bein[j]=-1; //标记此点已经遍历
		for(int k=1;k&lt;=n;k++)
			if(a[j][k]) //如果j和k之间有边相连
				bein[k]--; //和j相关联的节点删除与j相连的边，即入度--
	}
	return 1; //如果遍历过程中没有返回过假值，则有解，返回真值
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		a[x][y]=1; //邻接矩阵储存单向边
		bein[y]++; //输入是从x到y的连线，所以是y的入度增加
	}
	if(TS()) //如果有解
		for(int i=1;i&lt;=n;i++)
			cout&lt;&lt;sum[i]&lt;&lt;&quot; &quot;; //则输出节点的答案数组
	else
		cout&lt;&lt;&quot;no solution&quot;&lt;&lt;endl; //无解输出&quot;no solution&quot;
	return 0;
}
</code></pre>
<hr>
<h2 id="最小生成树英文缩写mst我忘了全称叫啥了反正知道了也没啥用">最小生成树（英文缩写<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span><s>我忘了全称叫啥了反正知道了也没啥用</s>）</h2>
<ul>
<li>
<p><strong>最小生成树</strong>：在一张带权的无向连通图中，<strong>各边权和为最小的一颗生成树</strong>即为最小生成树。<br>
<strong>简单讲：找出连接所有点的最低成本路线</strong>。<br>
举个栗子，下面这个图中的最小生成树就是用红线标出的：<br>
<img src="https://MrContinue.github.io/post-images/1588863097566.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>最小边原则</strong>：图中权值最小的边（如果唯一的话）一定在MST上。<br>
<strong>为啥</strong>？试想，既然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>的路径一定会连接至每个节点，那么我们一定会尽量选择最小的边以到达目标节点。<s>（不然合着有最短的路不走走绕路？？）</s></p>
</li>
</ul>
<h3 id="kruskal算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法</h3>
<h4 id="krudkal算法的基本知识"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>d</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Krudkal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法的基本知识</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法是一种贪心算法。为什么是贪心？知道了过程你就知道了。</p>
<h4 id="kruskal的操作方法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的操作方法：</h4>
<ol>
<li>按图中的边按权值<strong>从小到大</strong>快排（为啥？详见楼上【最小边原则】，您品，您细品）。</li>
<li>按照权值从小到大依次选边，若当前选取的边加入后使生成树形成环，则舍弃当前边（原因后面会讲的）；否则标记当前边已遍历并计数。</li>
<li>重复2的操作，直到生成树中包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>n</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（n-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>条边为止；否则当遍历完所有的边后，都不能选取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>n</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（n-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>条边，表示最小生成树不存在。</li>
</ol>
<p>从上面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span><strong>直接快排</strong>再<strong>无脑选边，当前不符合条件就直接舍弃，完全不考虑未来</strong>的步骤中，可以隐（强）约（烈）地感受到“鼠目寸光”的贪心内味。<s>（有内味了.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>p</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">jpg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>）</s></p>
<p>接下来咱简要的抠一抠算法里的细节。</p>
<h4 id="怎么判断当前边加入后mst会不会形成环">怎么判断当前边加入后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>会不会形成环？</h4>
<p>我们先来欣赏一个美丽的环，请您尽量把它想象成一棵变异了的<strong>二叉树</strong>——因为它<strong>有环</strong>：<br>
<img src="https://MrContinue.github.io/post-images/1588864164761.png" alt="" loading="lazy"><br>
可以看见，这棵奇怪的树分外耀眼的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">point</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>是<strong>节点4同时拥有了两个父亲——即节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></strong>。<br>
如果它与任意一个父亲断掉连接，那么它还是一棵健康茁壮的二叉树：<br>
<img src="https://MrContinue.github.io/post-images/1588948569959.png" alt="" loading="lazy"></p>
<p>所以我们可以推出，判断一棵树上有没有环，<strong>可以直接检查一个儿子是否拥有多个父亲</strong>。放在无向图里，我们可以变相理解为：多个节点是否同时联向同一个节点，即，<strong>有没有多个节点属于同一个集合</strong>。</p>
<p>欸？集合？判断？<br>
有没有很熟悉的感觉？<s>（别告诉我你没有，你就是有（大雾））</s></p>
<p>没错，你想起了<strong>并查集</strong>！就是那个<strong>可以储存所属集合、可以直接合并两个集合</strong>的神奇数据结构。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">How ever</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，我们就是用<strong>并查集</strong>来储存所有的节点，也正好利用它的特性——可以非常简单的判断所属集合，这点，来判断<strong>新加入的节点是否会让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>产生环</strong>。</p>
<h4 id="并查集的基本操作">并查集的基本操作：</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.</mn></mrow><annotation encoding="application/x-tex">1.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span></span></span></span> 找根节点：</p>
<pre><code class="language-cpp">int GetFather(int x)
{
	if(prt[x]==x) return x;
    return prt[x]=GetFather(prt[x]); //路径压缩
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn></mrow><annotation encoding="application/x-tex">2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span></span></span></span> 合并操作（一般可以直接写在主函数里）：</p>
<pre><code class="language-cpp">void Add(int x,int y)
{
    int f1=GetFather(x);
    int f2=GetFather(y);
    if(f1!=f2) prt[f1]=f2;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P3366"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1449</mn></mrow><annotation encoding="application/x-tex">1449</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span><span class="mord">9</span></span></span></span> 最小生成树</a></p>
<h4 id="description-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。
</code></pre>
<h4 id="input-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行包含两个整数N,M，表示该图共有N个结点和M条无向边。

接下来M行每行包含三个整数Xi,Yi,Zi，表示有一条长度为Zi的无向边连接结点 Xi,Yi。
</code></pre>
<h4 id="output-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。
</code></pre>
<h4 id="sample-input-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Sample Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
</code></pre>
<h4 id="sample-output-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Sample Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>7
</code></pre>
<h4 id="hint-2"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Hint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>对于20%的数据，N≤5，M≤20。
对于40%的数据，N≤50，M≤2500。
对于70%的数据，N≤500，M≤2×10^5。
对于100%的数据，1≤N≤5000，1≤M≤2×10^5。
</code></pre>
<p>样例解释：<br>
<img src="https://cdn.luogu.com.cn/upload/pic/2259.png" alt="" loading="lazy"><br>
所以最小生成树的总边权为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">2+2+3=7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define maxn 40005
using namespace std;

int n,m;
int prt[maxn]; //prt[i]表示节点i的根节点
int ans=0; //最小生成树的总权值和
bool flag; //标记是否有解

struct Edge
{
	int x,y,v;
}a[maxn]; 
//x[i]代表a[i]这条边的起点
//y[i]代表a[i]这条边的终点
//v[i]代表a[i]这条边的权值

bool cmp(Edge x,Edge y) //结构体数组排序函数
{
	return x.v&lt;y.v;
}

int GetFather(int x) //并查集查找根节点，这里使用了状态压缩
{
	if(prt[x]==x) return x;
	prt[x]=GetFather(prt[x]); //压缩
	return prt[x];
}

void K()
{
	int f1,f2;
	int k=0;
	for(int i=1;i&lt;=m;i++)
	{
		f1=GetFather(a[i].x);
		f2=GetFather(a[i].y); //分别找出x，y所属的集合，即根节点
		if(f1!=f2) //如果不属于同一集合，即不会形成环，则合并两集合
		{
			ans+=a[i].v; //累加最小生成树的权和总值值
			prt[f1]=f2; //两集合合并
			k++; //已遍历的节点累加
			if(k==n-1) //如果遍历到了所有点，则停止遍历
            //至于为什么是n-1，因为k的初始值是1啊qwq
				break;
		}
	}
	if(k&lt;n-1) //如果当遍历完所有的边后 都不能选取（n-1）条边 则表示最小生成树不存在
	{
		cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl;
		flag=1; //标记没有最小生成树
		return ;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].v;
	for(int i=1;i&lt;=n;i++)
		prt[i]=i; //并查集初始化
	sort(a+1,a+m+1,cmp); //按边权从小到大排好，以便贪心操作
	K();
	if(!flag) //如果有最小生成树，则输出最小权值
		cout&lt;&lt;ans&lt;&lt;endl; 
	return 0;
}
</code></pre>
<hr>
<h3 id="prim算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>算法</h3>
<h4 id="为啥有了kruskal算法还要学prim呢">为啥有了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法还要学<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>呢？</h4>
<p>因为两种算法可以用于两种不同类型的图：<strong>稠密图</strong>和<strong>稀疏图</strong>。多一种方法多一种思路嘛<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>。</p>
<h4 id="prim算法的操作方法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>算法的操作方法：</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.</mn></mrow><annotation encoding="application/x-tex">1.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span></span></span></span> 将根节点插入集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn></mrow><annotation encoding="application/x-tex">2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span></span></span></span> 在所有与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>集合的点相连的边中，找出一条<strong>最小的边</strong>，将这条边相连的另一个点——即<strong>未遍历的点，加入到集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中</strong>。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3.</mn></mrow><annotation encoding="application/x-tex">3.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span></span></span></span> 重复步骤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，直到所有节点都在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中。</p>
<p>简单来说，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>集合中的元素从一个<strong>根节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>开始</strong>，以<strong>一个集合整体出动</strong>的方式来扩展其他的点，以获取最小生成树。</p>
<p>用一个例子来表现一下上述内容，也许您会理解得更透彻。<br>
有一张图如下：<br>
<img src="https://MrContinue.github.io/post-images/1589117467732.png" alt="" loading="lazy"></p>
<p>首先，<strong>我们将数组初始化为最大，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，以表示此时每个节点与集合毫不相干</strong>，随后，我们将源点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>号放入集合中。由于源点本身与本身的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，所以数组更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>：<br>
<img src="https://MrContinue.github.io/post-images/1589117587248.png" alt="" loading="lazy"></p>
<p>录入当前与整个集合距离最小的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">d[5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。集合拓展为①、⑤：<br>
<img src="https://MrContinue.github.io/post-images/1589117665395.png" alt="" loading="lazy"></p>
<p>将与当前集合距离最近的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>放入集合中：<br>
<img src="https://MrContinue.github.io/post-images/1589117689666.png" alt="" loading="lazy"></p>
<p>接着放入节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，更新数组：<br>
<img src="https://MrContinue.github.io/post-images/1589117711223.png" alt="" loading="lazy"></p>
<p>此时可以发现，节点所连的点中出现了多个最小边权，即与①相连的③边权为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>；与②相连的⑥边权为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>；与⑤相连的⑥边权为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。由于我们现在是举例，所以随便选择一个即可。真正代码里是根据被循环到的先后次序来决定的。</p>
<p>这里拓展了③并更新数组：<br>
<img src="https://MrContinue.github.io/post-images/1589117788916.png" alt="" loading="lazy"></p>
<p>拓展④并更新数组：<br>
<img src="https://MrContinue.github.io/post-images/1589117813649.png" alt="" loading="lazy"></p>
<p>最后拓展完节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>的总值在应该是程序中一边遍历一边累加的：<br>
<img src="https://MrContinue.github.io/post-images/1589117854832.png" alt="" loading="lazy"></p>
<hr>
<h4 id="模板题和代码深入理解">模板题和代码深入理解</h4>
<p><a href="https://www.luogu.com.cn/problem/P3366"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1449</mn></mrow><annotation encoding="application/x-tex">1449</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span><span class="mord">9</span></span></span></span> 最小生成树</a></p>
<h4 id="description-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。
</code></pre>
<h4 id="input-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行包含两个整数N,M，表示该图共有N个结点和M条无向边。

接下来M行每行包含三个整数Xi,Yi,Zi，表示有一条长度为Zi的无向边连接结点 Xi,Yi。
</code></pre>
<h4 id="output-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。
</code></pre>
<h4 id="sample-input-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
</code></pre>
<h4 id="sample-output-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>7
</code></pre>
<h4 id="hint-3"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Hint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>对于20%的数据，N≤5，M≤20。
对于40%的数据，N≤50，M≤2500。
对于70%的数据，N≤500，M≤2×10^5。
对于100%的数据，1≤N≤5000，1≤M≤2×10^5。
</code></pre>
<p>样例解释：<br>
<img src="https://cdn.luogu.com.cn/upload/pic/2259.png" alt="" loading="lazy"><br>
所以最小生成树的总边权为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">2+2+3=7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define maxn 1005
using namespace std;

int a[maxn][maxn]; //元素数组
int d[maxn]; //d[i]表示不是生成树中点i到当前生成树中点的最小值
bool vis[maxn]; //vis[i]标记顶点i是否加入最小生成树中
int ans[maxn]; //答案数组

int n,m;
int sum;

int P(int x)
{
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=n;i++)
		d[i]=0x3f3f3f; //初始化
	d[x]=0; //第一个节点（即根节点）距离根节点（即自己）的距离为0
	int k;
	for(int i=1;i&lt;=n;i++)
	{
		int minn=0x3f3f3f; //统计最小边权
		for(int j=1;j&lt;=n;j++)
			if(!vis[j]&amp;&amp;d[j]&lt;minn) //如果节点j没有访问过且其边权小于当前最小边权
			{
				minn=d[j];
				k=j; //记录该节点			
			}
		vis[k]=1; //把该节点加入到集合中，设置状态为已访问
		sum+=d[k]; //累加总值
		for(int j=1;j&lt;=n;j++)
			if(!vis[j])
				d[j]=min(d[j],a[k][j]); //更新集合到每个点的最短距离
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			a[i][j]=0x3f3f3f; //初始化
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		a[x][y]=v;
		a[y][x]=v; //邻接数组建双边
	}
	P(1); //从1开始遍历
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr>
<h2 id="最短路径问题">最短路径问题</h2>
<ul>
<li>
<p><strong>最短路径</strong>：在一个有权图中连接给定两个顶点的权值和最小的路径。</p>
</li>
<li>
<p><strong>最短路树和最小生成树可以不一样</strong>。</p>
</li>
<li>
<p>一般有两类最短路问题：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>S</mi><mi>S</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">SSSP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>（单源最短路）：求<strong>给定起点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>到其他所有点</strong>的最短路，常见算法有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>算法等。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>P</mi><mi>S</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">APSP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>（多源最短路）：求<strong>任意两对顶点</strong>之间的最短路，常见算法有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyed</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span>算法。</li>
</ol>
<p>单讲概念有点生涩，上一个例子理解一下：<br>
在下图中：<br>
<img src="https://MrContinue.github.io/post-images/1589118649290.png" alt="" loading="lazy"><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>S</mi><mi>S</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">SSSP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>：只求<strong>①到⑤的最短路</strong>这一条最短路的值，<strong>即起点到终点的最短路</strong>。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>P</mi><mi>S</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">APSP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>：求<strong>①到③的最短路、②到④的最短路、①到⑤的最短路……即任意两点之间的最短路</strong>。</p>
</li>
</ul>
<h3 id="dijkstra算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法</h3>
<h4 id="三角形性质">三角形性质：</h4>
<p>设源点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>到点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的最短路径长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>之间的距离是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>，则有下面的“三角形定理”：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+g[x][y]&gt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<h5 id="这段话是什么意思">这段话是什么意思？</h5>
<p>首先给定两个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>和它们的距离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>：<br>
<img src="https://MrContinue.github.io/post-images/1589119940828.png" alt="" loading="lazy"></p>
<p>接着我们向上拓展出一个与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>相连的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，其最短距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>。<br>
<img src="https://MrContinue.github.io/post-images/1589120116971.png" alt="" loading="lazy"></p>
<p>求解最短路的时候需要满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+g[x][y]&gt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<h4 id="松弛">松弛：</h4>
<p>若在处理过程中，有两点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>出现不符合“三角形定理”，则可“松弛一下”，即：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>if(d[x]+g[x][y]&lt;d[y]) </mtext><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">\text{if(d[x]+g[x][y]&lt;d[y])}\text{ }d[y]=d[x]+g[x][y];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">if(d[x]+g[x][y]&lt;d[y])</span></span><span class="mord text"><span class="mord"> </span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></p>
<h4 id="dijkstra算法的操作方法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法的操作方法：</h4>
<p>设根节点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span>，数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到根节点的最短距离。</p>
<ul>
<li>
<p>初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>v</mi><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d[v0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span>到其他点的距离值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">d[i]=inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>。</p>
</li>
<li>
<p>经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次如下步骤操作，最后得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个顶点的最短距离：</p>
<ol>
<li>选择一个未标记（即未遍历过）的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>的值是当前最小的（之所以选当前最小的点开始继续连点是因为，<strong>最小的点可以有期望让到其他的点的边权尽量小</strong>）。</li>
<li>标记点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>已遍历，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">vis[k]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
<li>以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为中间点，修改源点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">v0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">0</span></span></span></span>到其他未标记点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的距离值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>（即，又以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为媒介，继续遍历其他与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>相连但没有被遍历的点，到源点的新距离）。</li>
</ol>
</li>
</ul>
<h4 id="个人小议dijkstra算法与prim算法的不同">个人小议<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>算法的不同：</h4>
<ul>
<li>
<p>目的上，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>求最小生成树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>求最短路</p>
</li>
<li>
<p>距离上，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>是让在集合里的<strong>所有点</strong>中，找到与之相连的一条最短边。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>是从原点开始更新距离，然后点连点更新距离；</p>
</li>
<li>
<p>连点上，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>是一个集合连所有点<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>是一个点只能连直接与自己相关联的点，在开始连接新的点的时候，从最小的点开始继续访问</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>算法数组里存的是点到集合的距离<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法数组里存的是所有点到源点的距离</p>
</li>
</ul>
<p>总的来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Prim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>有很多相似之处，但有很多细节还是不同的，还是要注意区分和理解。</p>
<hr>
<h4 id="模板题和代码深入理解-2">模板题和代码深入理解</h4>
<p><a href="https://www.luogu.com.cn/problem/P4779"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1428</mn></mrow><annotation encoding="application/x-tex">1428</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 最短路径问题</a></p>
<h4 id="description-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>平面上有n个点（n&lt;=100），每个点的坐标均在-10000~10000之间。其中的一些点之间有连线。
若有连线，则表示可从一个点到达另一个点，即两点间有通路，通路的距离为两点间的直线距离。现在的任务是找出从一点到另一点之间的最短路径。
</code></pre>
<h4 id="input-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>共n+m+3行，其中:
第一行为整数n。
第2行到第n+1行（共n行） ，每行两个整数x和y，描述了一个点的坐标。
第n+2行为一个整数m，表示图中连线的个数。
此后的m 行，每行描述一条连线，由两个整数i和j组成，表示第i个点和第j个点之间有连线。
最后一行：两个整数s和t，分别表示源点和目标点。
</code></pre>
<h4 id="output-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>一行，一个实数（保留两位小数），表示从s到t的最短路径长度。
</code></pre>
<h4 id="sample-input-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>5 
0 0
2 0
2 2
0 2
3 1
5 
1 2
1 3
1 4
2 5
3 5
1 5
</code></pre>
<h4 id="sample-output-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>3.41
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

#define maxn 1005
using namespace std;

double a[maxn]; //a[i]表示不是生成树中点i到源点的最小值
double g[maxn][maxn]; //邻接数组存边
int prt[maxn]; //记录自己的值是从哪个节点来的，即为相对的父亲节点
bool vis[maxn]; //标记是否访问过
int s,t; //起点和终点
int n,m;

struct Node
{
	int x,y;
}q[maxn]; //储存坐标

double len(Node a,Node b) //通过x、y坐标计算边的长度
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

void D()
{
	for(int i=1;i&lt;=n;i++)
		a[i]=999999.9; //初始化为最大值，表示此时每个节点与集合毫不相干
	int k;
	a[s]=0; //第一个节点（即根节点）距离根节点（即自己）的距离为0
	prt[s]=0; //第一个节点的父亲定义为0
	for(int i=1;i&lt;=n;i++)
	{
		double minn=999999.9; //找最小边权
		for(int j=1;j&lt;=n;j++)
			if(!vis[j]) //如果未访问过
				if(a[j]&lt;minn) //且此边权小于当前最小边权
				{
					minn=a[j]; //则更新最小边权
					k=j; //记录此节点
				}
		vis[k]=1; //访问该节点
		for(int j=1;j&lt;=n;j++)
			if(g[k][j]&gt;0&amp;&amp;!vis[j]) //更新与该节点有连接且未被遍历的点的边权值
				if(a[k]+g[k][j]&lt;a[j]) //松弛操作
				{
					a[j]=a[k]+g[k][j];
					prt[j]=k; //记录更新它的值的节点
				}
	}
}

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		q[i].x=x;
		q[i].y=y; //记录坐标
	}
	cin&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		double v=len(q[x],q[y]); //计算边权
		g[x][y]=v;
		g[y][x]=v; //邻接矩阵建双边
	}
	cin&gt;&gt;s&gt;&gt;t;
	D();
	printf(&quot;%.2f&quot;,a[t]); //直接输出节点t距离源点s的距离
	return 0;
}
</code></pre>
<h4 id="寻找优化的办法选读内容">寻找优化的办法（选读内容）</h4>
<p>我们可以发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>是一个很好理解的算法，但是当节点一多，它较高的复杂度就显得有些力不从心了。所以我们试图寻找一种方法，使得它的复杂度能降到我们满意的程度。</p>
<p>那么我们简单分析一下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法的大概步骤：</p>
<ol>
<li>初始化</li>
<li>找当前集合内最小边权</li>
<li>更新每个节点新的边权值</li>
</ol>
<p>在这三步里，初始化这一步很明显无法优化；而更新节点一定是要落实到每个节点的，所以循环一次的复杂度也是在做难免的。<br>
那么我们的目光很确定的指向了【找当前集合内最小边权】这一步的优化方式。</p>
<p>还记得我们曾经学过的数据结构堆吗？它可以用一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>T</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">STL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span></span></span></span>库<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">priority</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>_<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>来实现。它插入元素的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，而查找元素的复杂度仅为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。所以我们大可利用它<strong>可以排序</strong>、<strong>查找复杂度低</strong>的特点对【找当前集合内最小边权】进行优化。</p>
<p>说详细一点，就是用一个结构体，<strong>将当前节点序号和它到源点的距离</strong>封装起来，再建立一个<strong>结构体优先队列</strong>进行操作。由于堆会维护自身的大小，所以取出时可以到达和原来一个循环做到的一个效果。</p>
<p>至于结构体优先队列的具体操作、优化版<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>的具体代码操作和例题详解，可移步至<a href="https://mrcontinue.xyz/post/zheng-li-qi-fa-shi-sou-suo-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97bfs">这里</a>以获取更详细的知识。</p>
<hr>
<h3 id="floyd算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法</h3>
<h4 id="floyd算法的基本知识"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法的基本知识：</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>思想。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法可以处理有向图或无向图，但<strong>图中不能有负环</strong>。</li>
</ul>
<h4 id="floyd算法的基本思想"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Floyd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">d</span></span></span></span>算法的基本思想：</h4>
<ul>
<li>
<p>初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]=w[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，从小到大枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，对每对节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>u</mi><mi mathvariant="normal">，</mi><mi>v</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（u，v）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">u</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">）</span></span></span></span>，检查它们的最短路值。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示该状态下（即路径中间只允许经过节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的情况下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>递增，定义在循环内），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最短路距离<br>
其状态转移方程分为两种情况进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>：</p>
<ol>
<li><strong>最短路经过点k</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][k]+f[k][j];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></li>
<li><strong>最短路不经过点k</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>（这里等号右边的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>实为上一阶段的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>）</li>
</ol>
</li>
</ul>
<h4 id="状态转移方程简单分析">状态转移方程简单分析</h4>
<p>其实这是一个一眼就能看出来的概念，这里在将图画出来，更便于大家理解，看看自己当初的理解是否有误。</p>
<ol>
<li>两点之间有其它点。<br>
如图：<br>
<img src="https://MrContinue.github.io/post-images/1589206151924.png" alt="" loading="lazy"><br>
能一眼看出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][k]+f[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>。</li>
<li>两点之间并没有任何的其他点，<strong>直接相连</strong>。<br>
如图：<br>
<img src="https://MrContinue.github.io/post-images/1589207703218.png" alt="" loading="lazy"></li>
</ol>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1584"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1584</mn></mrow><annotation encoding="application/x-tex">1584</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">8</span><span class="mord">4</span></span></span></span> 银行设置</a><br>
（没有找到大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">OJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>的题目链接各位大佬还是将就着题干看吧，提交还是随缘吧（（（）</p>
<h4 id="description-5"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>经过几十年的奋斗，X童鞋终于学出头了，他当了老板！有了钱的X童鞋回到了他亲爱的家乡，他发现，家乡的筒子们因为生在山卡卡里，所以十分跟不上潮流，借钱都要用鸡抵押，存钱都要塞在床底下。X童鞋觉得这很不科学，决定在他的家乡设置银行。但是，由于这个村里的筒子都太懒了，不肯多走几步，所以，X童鞋准备在n个居民点v1,v2,…,vn中设置两个很科学的银行，使每个村民都能懒到神一般的级别，所有人到银行的最短距离之和最小。然而，X童鞋也十分懒，所以，这个任务就交给勤奋的你们了O(∩_∩)O~
</code></pre>
<h4 id="input-5"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行有两个正整数N,M,分别表示居民点数和路的条数(N&lt;=100,M&lt;=10000）。
接下来M行，每行三个正整数，分别表示每一条路的两个端点编号和长度。
</code></pre>
<h4 id="output-5"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>输出两个银行分别设置在什么地方，如果有多个解，输出编号最小的两个
</code></pre>
<h4 id="sample-input-5"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>3 3
1 2 1
2 3 2
1 3 2
</code></pre>
<h4 id="sample-output-5"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>1 3
</code></pre>
<p><strong>初始化</strong>：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mo>=</mo><mi>j</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">己</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">己</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi><mi mathvariant="normal">为</mi><mn>0</mn><mi mathvariant="normal">）</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>i</mi><mi>n</mi><mi>f</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>!</mo><mo>=</mo><mi>j</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">初</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">毫</mi><mi mathvariant="normal">无</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">联</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">即</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi><mi>i</mi><mi>n</mi><mi>f</mi><mi mathvariant="normal">）</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}f[i][j]=0&amp;i==j（自己到自己的距离为0）\\f[i][j]=inf&amp;i!=j（初始设置为两节点毫无关联，即距离上等于inf）\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">己</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">己</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">为</span><span class="mord">0</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">初</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">毫</span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">联</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
#define inf 0x3f3f3f
using namespace std;

int f[maxn][maxn]; //操作数组，f[i][j]表示该状态下（即路径中间只允许经过节点i~k的情况下，k递增，定义在循环内），i到j的最短路距离
int n,m;
int a[maxn][maxn]; //a[i][j]表示坐标为(i,j)的点对于两个银行设置的距离值

void Floyed()
{
	for(int k=1;k&lt;=n;k++) //枚举中间点
		for(int i=1;i&lt;=n;i++) //枚举起点
			for(int j=1;j&lt;=n;j++) //枚举终点
				if(f[i][k]!=inf&amp;&amp;f[k][j]!=inf) //如果i、j同时与点k有关联，即上述分析的第一种情况
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]); //则i、j两点之间的距离等于ik和kj两部分的距离之和
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(i==j) f[i][j]=0;
			else f[i][j]=inf; //初始化，自己到自己的最短路设置为0,
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		f[x][y]=f[y][x]=v; //邻接矩阵建边
	}
	Floyed();
	for(int k=1;k&lt;=n;k++)
		for(int i=1;i&lt;n;i++)
			for(int j=i+1;j&lt;=n;j++) //为了避免重复从i+1开始遍历另一种点
				a[i][j]+=min(f[i][k],f[k][j]); //由于设置两个银行，所以取f[i][k]与f[k][j]的最小值
	int ans=inf;
	int ans1,ans2;
	for(int i=1;i&lt;n;i++)
		for(int j=i+1;j&lt;=n;j++)
			if(a[i][j]&lt;ans) //取最小值
			{
				ans=a[i][j];
				ans1=i; //记录节点序号
				ans2=j; 
			}
	cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl;
	return 0;
}
</code></pre>
<h3 id="spfa算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>算法</h3>
<h4 id="spfa算法的基本思想和操作方法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>算法的基本思想和操作方法</h4>
<ol>
<li>
<p>用一个队列储存待优化的<strong>节点</strong>（注意，这里队列里储存的是<strong>节点</strong>，而堆优化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Dij</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的<strong>优先队列</strong>里则储存的是<strong>从这个节点和它对应的到源点的最短路径的距离</strong>，我们可以近似的看成一条“路径”。这里由于我曾经迷惑过一段时间，所以特此提示）</p>
</li>
<li>
<p>每次优化是取出队首元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，遍历每个和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>相关的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是否需要进行<strong>松弛操作</strong>。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>进行了松弛操作，即它更新了<strong>自己到源点的距离</strong>，则将它放入队列中。</p>
</li>
<li>
<p>反复循环，直至队列为空。</p>
</li>
</ol>
<h4 id="常见疑惑">常见疑惑：</h4>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">SPFA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">A</span></span></span></span>算法的复杂度？<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>：玄学，平均复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，其大时可以极大，小时可以极小<s>所以才说SPFA它死了啊</s>。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>：在算法中，如果后出队的点可以使前面的点更忧，而那个点的值改变了，它的子节点的值也会改变。这个时候需要入队吗？<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>：需要，而且不用担心<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">vis[i]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的问题。当我们出队以后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">vis[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>会归零的。</p>
</li>
</ol>
<p><a href="https://www.luogu.com.cn/problem/P3371"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1580</mn></mrow><annotation encoding="application/x-tex">1580</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">8</span><span class="mord">0</span></span></span></span> 最短路<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>p</mi><mi>f</mi><mi>a</mi><mo>)</mo><mn>2885</mn></mrow><annotation encoding="application/x-tex">(Spfa)2885</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">2</span><span class="mord">8</span><span class="mord">8</span><span class="mord">5</span></span></span></span></a></p>
<h4 id="description-6"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步P4779。
</code></pre>
<h4 id="input-6"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行包含三个整数n,m,s分别表示点的个数、有向边的个数、出发点的编号。
接下来m行每行包含三个整数u,v,w表示一条u→v的，长度为w的边。
</code></pre>
<h4 id="output-6"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>输出一行n个整数，第i个表示s到第i个点的最短路径，若不能到达则输出 2^{31}−1
</code></pre>
<h4 id="sample-input-6"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
</code></pre>
<h4 id="sample-output-6"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>0 2 4 3
</code></pre>
<h4 id="hint-4"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Hint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></h4>
<p>【数据范围】</p>
<pre><code>对于20%的数据：1≤n≤5，1≤m≤15；
对于40%的数据：1≤n≤100，1≤m≤10^4；
对于70%的数据：1≤n≤1000，1≤m≤10^5；
对于100%的数据：1≤n≤10^4，1≤m≤5×10^5，保证数据随机。
对于真正100%的数据，请移步P4779。请注意，该题与本题数据范围略有不同。
</code></pre>
<p>样例解释<br>
<img src="https://cdn.luogu.com.cn/upload/pic/7641.png" alt="" loading="lazy"></p>
<pre><code>图片1到3和1到4的文字位置调换。
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;

#define maxn 500010
using namespace std;

queue &lt;int&gt; q;

int vis[maxn]; //vis[i表示点i是否在队中
int d[maxn]; //d[i表示点i距离源点的最短路

struct Edge
{
	int to,next,v;
}a[maxn&lt;&lt;1]; //前向星结构体数组


int head[maxn],cnt;
//int used[maxn]; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
int n,m;

void AddEdge(int x,int y,int v) //前向星建边操作
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	head[x]=cnt;
	a[cnt].v=v;
}

int Spfa(int x)
{
	for(int i=1;i&lt;=n;i++)
		d[i]=0x3f3f3f3f;
//	memset(vis,0,sizeof(vis));
	q.push(x);
	vis[x]=1;
	d[x]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0; //因为点u已出队，释放点u
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]&gt;d[u]+a[i].v) //松弛操作
			{
//				used[v]++;
//				if(used[v]&gt;n) return 0; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
				d[v]=d[u]+a[i].v; //更新边权
				if(!vis[v]) //如果点v可以遍历（可以添加）
				{
					vis[v]=1; //标记已在队中
					q.push(v); //则入队
				}
			}
		}
	}
//	return 1; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		AddEdge(x,y,v);
		AddEdge(y,x,v); //前向星建双边
	}
//	if(Spfa(1))
//		cout&lt;&lt;d[n]&lt;&lt;endl; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
	Spfa(1);
	cout&lt;&lt;d[n]&lt;&lt;endl; //直接输出
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h2 id="有向图的连通性">有向图的连通性</h2>
<p><strong>关于有向图的相关概念</strong>：</p>
<ul>
<li>
<p><strong>父子边</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的父亲，边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>可理解为一条父子边。</p>
</li>
<li>
<p><strong>返祖边</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的父亲，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>的父亲，边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>可理解为一条返祖边。</p>
</li>
<li>
<p><strong>横叉边</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的父亲，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>的父亲，边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">BC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>可理解为一条横叉边。</p>
</li>
<li>
<p><strong>强连通图</strong>：有向图中，如果对每一对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Vi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Vj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Vi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Vj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Vi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span></span></span></span>不等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Vj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)。从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Vi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Vj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>和从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Vj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Vi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span></span></span></span>都存在路径，则称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>是强连通图。<br>
简单来说，即：<strong>如果一张有向图中任意两点有路径可以互相到达，则称这张图是强连通图</strong></p>
</li>
<li>
<p><strong>强连通分量</strong>：有向图的极大强连通子图叫强连通分量。</p>
</li>
</ul>
<h3 id="tarjan算法"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>算法</h3>
<h4 id="tarjan算法可以用来干什么"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>算法可以用来干什么？</h4>
<ol>
<li>
<p>求出有向图的强连通分量，无向图的双连通分量（后面会讲的）</p>
</li>
<li>
<p>在线性的时间内求出无向图的割点和桥（后面会讲的）</p>
</li>
</ol>
<h4 id="tarjan算法的基本知识部分思路来源于算法竞赛进阶指南"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>算法的基本知识（部分思路来源于《算法竞赛进阶指南》）</h4>
<h5 id="从一张没有灵魂的图说起">从一张没有灵魂的图说起</h5>
<p>这里有一张没有灵魂的无向图：<br>
<img src="https://MrContinue.github.io/post-images/1591708226129.png" alt="" loading="lazy"></p>
<p>可以发现它没有灵魂的原因在于它没有每个节点的编号（极其牵强的理由）。<br>
所以我们应该怎么为节点们编号呢？</p>
<p>……</p>
<h5 id="时间戳dfn我们有时会叫它豆腐脑doufunao嘛">时间戳（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">DFN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，<s>我们有时会叫它“豆腐脑”，DouFuNao嘛</s>）</h5>
<p>有啦！<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>是一个非常棒的东西，用它的遍历次序来编号，即不会重，又不会漏。<br>
所以我们可以将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>第一次遍历到一个节点的次序作为它的“编号”。事实上，我们管这些“编号”叫做<strong>时间戳</strong>，记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>N</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">DFN[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>。</p>
<p>在我们的努力下，这张图有了灵魂：<br>
<img src="https://MrContinue.github.io/post-images/1591708363762.png" alt="" loading="lazy"></p>
<h5 id="搜索树">搜索树</h5>
<p>有了一张有灵魂的图，我们忍不住对它进行了一次遍历。这样，便走出了一棵<strong>搜索树</strong>（右图）：<br>
<img src="https://MrContinue.github.io/post-images/1591709091067.png" alt="" loading="lazy"></p>
<p>所谓搜索树，就是<strong>从无向图的一个节点开始递归，每个店只访问一次，所有可以遍历到的边（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>）（换言之，从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的第一次访问）构成的一棵树。</strong></p>
<h5 id="追溯值low就是你好low啊的那个low">追溯值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">LOW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，<s>就是“你好LOW啊”的那个LOW</s>）</h5>
<p>有了一棵搜索树，我们引入一个概念：“追溯值”，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>。设有一棵以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为根的搜索树<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>是以下两个范围中<strong>节点时间戳的最小值</strong>：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>中的节点。</li>
<li>可以通过一条边到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>而不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>上的节点。</li>
</ol>
<p>看到这里别懵啊，不是我的语言艺术不够丰富，是太绕了（确信）举个栗子理解一下吧？<br>
<img src="https://MrContinue.github.io/post-images/1591710169468.png" alt="" loading="lazy"><br>
还是上图这张美丽的图。我们用<strong>时间戳代表编号</strong>。</p>
<p>以节点2为例。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>={<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2,3,4,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span></span></span></span>}，然后我们进行第一步，即<strong>寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>中的节点的最小值</strong>。目前可以得到：<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">min(2,3,4,5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></strong>。<br>
现在进行第二步，即<strong>寻找一个【可以通过一条边到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>而不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>上的节点】</strong>.不难发现节点1符合这样的条件，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">min(2,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>聪明的你，一定懂了叭？<br>
紧接着问题来了，怎么计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">LOW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>值呢？</p>
<h5 id="追溯值low值的求解">追溯值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">LOW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>值）的求解</h5>
<p>根据定义，为了计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>，我们应<strong>先将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>的初始值赋为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>N</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">DFN[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span></strong>。（为什么？其实是为了方便判断当前节点所连的子树是否为单独的强连通分量。但这已经扯到比较后面了，所以先放一放叭。）接着<strong>进行刚刚我们分析了好久的那两步</strong>：</p>
<ol>
<li>如果有一节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>上，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">min(LOW[x],LOW[y])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
<li>如果节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>上，但直接与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>相连通时，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>D</mi><mi>F</mi><mi>N</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">min(LOW[x],DFN[y])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p>比较模糊还是有点懵？下面我们一起来举个栗子吧！<br>
<img src="https://MrContinue.github.io/post-images/1591710169468.png" alt="" loading="lazy"><br>
还是上面这张美丽的图。</p>
<p>从节点1开始。初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>D</mi><mi>F</mi><mi>N</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">LOW[1]=DFN[1]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>={<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1,2,3,4,5,6,7,8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span></span></span></span>}，无<strong>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>上却与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>直接相连的点</strong>。所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">min(1,2,3,4,5,6,7,8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span><strong>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></strong>。</p>
<p>接着遍历节点2。初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mi>D</mi><mi>F</mi><mi>N</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">LOW[2]=DFN[2]=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>={<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2,3,4,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span></span></span></span>}。节点1是<strong>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>上却与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>直接相连的点</strong>。所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi><mo>[</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">LOW[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">min(1,2,3,4,5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span><strong>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></strong>。</p>
<p>以此类推，我们可以得出下图（[]里的数字是节点对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>O</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">LOW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>值）：</p>
<h4 id="tarjan算法简化操作步骤"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>算法简化操作步骤：</h4>
<ul>
<li>
<p>找一个没有被访问过的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>；否则，算法结束；(图不连通)</p>
</li>
<li>
<p>初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span><br>
对于u所有的邻接顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>：</p>
<ol>
<li>如果没有访问过，则转到步骤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，同时维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>；</li>
<li>如果访问过，但没有删除，维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>；</li>
</ol>
</li>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>==<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>，那么输出相应的强连通分量。</p>
</li>
</ul>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1572"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1572</mn></mrow><annotation encoding="application/x-tex">1572</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">7</span><span class="mord">2</span></span></span></span> 消息的传递<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2269</mn></mrow><annotation encoding="application/x-tex">2269</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">6</span><span class="mord">9</span></span></span></span></a><br>
（没有找到大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">OJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>的题目链接，委屈各位大佬了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">orz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>）</p>
<h4 id="description-7"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>我们的郭嘉大大在曹操这过得逍遥自在，但是有一天曹操给了他一个任务，在建邺城内有N（&lt;=1000）个袁绍的奸细，将他们从1到N进行编号，同时他们之间存在一种传递关系，即若C[i，j]=1，则奸细i能将消息直接传递给奸细j。
现在曹操要发布一个假消息，需要传达给所有奸细，而我们的郭嘉大大则需要传递给尽量少的奸细使所有的奸细都知道这一个消息，问我们至少要传给几个奸细
</code></pre>
<h4 id="input-7"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行是两个整数N，M（N&lt;=100,M&lt;=1000），分别表示网络的结点个数和弧数。
第二行至M+1行，每行三个整数A，B，C，表示弧上的损耗为C。
</code></pre>
<h4 id="output-7"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>输出仅一个整数，为损耗最大的线路的损耗量。
</code></pre>
<h4 id="sample-input-7"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>5 5
1 2 2
2 4 9
1 3 7
3 4 1
4 5 6
</code></pre>
<h4 id="sample-output-7"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>17
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;

#define maxn 1005
#define inf 0x7fffffff/2
using namespace std;

stack &lt;int&gt; q;
int in[maxn][maxn]; //入度
int DFN[maxn],LOW[maxn]; 
int from[maxn]; //找所属 
bool flag[maxn]; //标记数组
int bein[maxn]; //强连通分量入度 

int cnt;
int t; //时间戳 
int y;
int n;

void Tarjan(int x)
{
	DFN[x]=LOW[x]=++t; //给x按照访问顺序的先后标号为t，给LOW[x]赋初始值
	q.push(x); //x点进栈
	flag[x]=1; //这个用来判断横叉边
	for(int i=1;i&lt;=n;i++)
		if(in[x][i]) //边xi没有被标记过
			if(!DFN[i]) //i未被标记过
			{
				Tarjan(i); //xi是父子边，递归访问
				LOW[x]=min(LOW[i],LOW[x]);
			}
			else if(flag[i])
				LOW[x]=min(DFN[i],LOW[x]); //xi是返祖边
	if(LOW[x]==DFN[x]) //统计块数
	{
		cnt++;
		while(y!=x)
		{
			y=q.top();
			q.pop();
			from[y]=cnt; //定义当前快的编号为cnt
			flag[y]=0; //释放标记
		}
	}
}

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			cin&gt;&gt;in[i][j]; //邻接矩阵存储边关系
	for(int i=1;i&lt;=n;i++)
		if(!DFN[i]) Tarjan(i); //如果没有遍历过，则遍历一遍
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(in[i][j]&amp;&amp;from[i]!=from[j])
				bein[from[j]]++; //统计每个块的入度
	int sum=0; //统计需要传播给多少个人
	for(int i=1;i&lt;=cnt;i++)
		if(!bein[i])
			sum++; //如果有块入度为零，代表必须单独传播信息，所以sum++
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h3 id="无向图的连通性">无向图的连通性</h3>
<h4 id="割点">割点</h4>
<h5 id="割点是什么">割点是什么？</h5>
<p>割点是一张无向图中<strong>非常重要</strong>的点。（额……不是废话）在一张连通的无向图中，如果突然少了一个割点，那么这个图就会变得不连通。</p>
<p>以下面这张（我们很熟悉的）图为例：<br>
<img src="https://MrContinue.github.io/post-images/1591797139368.png" alt="" loading="lazy"></p>
<p>其中节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>就是割点之一。因为如果没有了节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>，这张图就会变成这样：<br>
<img src="https://MrContinue.github.io/post-images/1591797820993.png" alt="" loading="lazy"><br>
这样就易懂很多啦qwq</p>
<p>但是这时候聪明的大佬宁可能要问了，说割点就是“很重要的点”是非常不严谨的不良行为（主要是不利于装<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">bushi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span></span></span></span>））</p>
<h5 id="严肃的概念介绍割点">（严肃的）概念介绍：割点</h5>
<ol>
<li>定义：<br>
在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点及与该顶点相关联的边时, 也不破坏图的连通性。<strong>如果一个图不是双连通的，那么，将其删除后图将不再连通的那些顶点称为割点。</strong></li>
<li>求割点的算法：<br>
我们通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>把无向图定向成有向图，定义每个顶点两个参数：<br>
① <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>表示顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>访问的先后顺序。<br>
②$ lowlink[u]<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">沿</mi></mrow><annotation encoding="application/x-tex">表示沿</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">沿</span></span></span></span>u<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">出</mi><mi mathvariant="normal">发</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">轨</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">够</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">点</mi></mrow><annotation encoding="application/x-tex">出发的有向轨能够到达的点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">轨</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">够</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">点</span></span></span></span>v<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">中，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span></span></span></span>dfn[v]$值的最小值 (经过返祖边后则停止)</li>
<li>三个定理<br>
【定理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>】：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">e=ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span></span></span></span>是返祖边，那么要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的祖先，要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的后代子孙。<br>
【定理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>】：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>u</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">e=uv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>是父子边，且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dfn[u]&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>≥</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">lowlink[v]≥dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>是割点。<br>
【定理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>】：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的根<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>是割点的充要条件是：至少有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>条以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>为尾(从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>出发)的父子边。</li>
<li>求割点的算法：</li>
</ol>
<pre><code class="language-cpp">void DFS(int u)
{ 
	sign++;
	dfn[u]=sign; //给u按照访问顺序的先后标号为sign
	lowlink[u]=sign; //给lowlink[u]赋初始值
	for(int v=1;v&lt;=n;v++) //寻找一个u的相邻节点v
		if(MAP[u][v]&amp;&amp;prt[u]!=v) // u→v有边相连且不是回边
		{
      	if(dfn[v]==0) //v未被访问
			{
          	prt[v]=u; //则u是v的父亲
				DFS(v); //uv是父子边，递归访问v
				lowlink[u]=min(lowlink[u],lowlink[v]);//所有儿子中最小值
				if(lowlink[v]&gt;=dfn[u])
				{
              	if(dfn[u]==1)
                  {
                  	son++;
                      if(son&gt;=2) cout&lt;&lt;u&lt;&lt;endl;
                  }//根
				else cout&lt;&lt;u&lt;&lt;endl;//u是割点
		        }
	       }
         else lowlink[u]= min(lowlink[u],dfn[v]);
	   //若已访问则访问时间一定早于u，uv是返祖边
    }
}
</code></pre>
<h4 id="割边">割边</h4>
<h5 id="割边是什么">割边是什么？</h5>
<p>知道了割点是<strong>很重要的点</strong>，自然，割边就是<strong>很重要的边</strong>啦~（<br>
<s>别打我QAQ</s><br>
同样的，如果有一条边突然不见了，能使得整个图变成几个<strong>独立的、封闭的</strong>部分，则这条边是割边。<br>
又双叒是这个图，我们给每条边起个名字qwq<br>
<img src="https://MrContinue.github.io/post-images/1594473766345.png" alt="" loading="lazy"><br>
其中边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>就是一条割边。因为如果没有了边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，这张图就会变成这样：<br>
<img src="https://MrContinue.github.io/post-images/1594473843220.png" alt="" loading="lazy"></p>
<h5 id="判定割边的方法部分摘自资料算法竞赛进阶指南">判定割边的方法（部分摘自资料：《算法竞赛进阶指南》）</h5>
<p>如果两个节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>满足：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant="normal">＜</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[x]＜low[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord cjk_fallback">＜</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span><br>
则可以判定边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是一条割边。</p>
<p>根据定义，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant="normal">＜</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[x]＜low[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord cjk_fallback">＜</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>说明从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>出发，在不经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的前提下，不管走哪条边，都无法到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>或比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更早访问的节点。若把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>删除，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>就好像形成了一个封闭的环境，与节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>没有边相连，图断开成了两部分，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是割边。<br>
反之，若不存在这样的子节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant="normal">＜</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[x]＜low[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord cjk_fallback">＜</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>，则说明每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">subtree(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>都能绕行其他变到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>或比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更早访问的节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>自然就不是割边。</p>
<ul>
<li>
<p><strong>割边</strong>：</p>
<ol>
<li>定义：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>是连通图，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>∈</mo><mi>E</mi><mo>(</mo><mi>G</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">e∈E(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>−</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">G-e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>不再连通，则称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>的割边，亦称做桥。</li>
</ol>
<p>2.求割边的算法<br>
与割点类似的，我们定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>。父子边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">e=u→v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，当且仅当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>&gt;</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[v]&gt;dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>的时候，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>是割边。</p>
<p>3.求割边的参考代码：</p>
<pre><code class="language-cpp">void DFS(int u)
{
   sign++;
   dfn[u]=sign; //给u按照访问顺序的先后标号为sign
   lowlink[u]=sign; //给lowlink[u]赋初始值
   for(寻找一个u的相邻节点v)
      if(边uv没有被标记过)
      {
         标记边uv;
         给边定向u→v;
         if(v未被标记过)
         {
            DFS(v); //uv是父子边，递归访问
            lowlink[u]=min(lowlink[u],lowlink[v]);
            if(lowlink[v]&gt;dfn[u])uv是割边
         }
         else lowlink[u]=min(lowlink[u],dfn[v]);//uv是返祖边
      }
}
</code></pre>
<ol>
<li>割点与割边<br>
<strong>两个割点之间的边不是割边，割边的两端点不是割点。</strong></li>
</ol>
</li>
<li>
<p>块<br>
1.定义：<br>
没有割点的图叫连通图，亦称做块。把每个块收缩成一个点，就得到一棵树，它的边就是桥。</p>
<p>2.求块的算法：<br>
在求割点的算法中，当结点u的所有邻边都被访问过之后，如果存<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">lowlink[u]=dfn[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span>，我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>下方的整块和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>导出作为图中的一个块。<br>
这里需要用一个<strong>栈</strong>来表示哪些元素是u代表的块。</p>
</li>
</ul>
<h2 id="关键路径">关键路径</h2>
<p><strong>关于关键路径的相关概念</strong>：</p>
<p>定义：在一个给定的有向无环图中，求从<strong>开始顶点到结束顶点的最长路径</strong>（路径上的<br>
权值和）叫关键路径。</p>
<p>算法步骤：</p>
<ol>
<li>读入数据，建立有向图</li>
<li>对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DAG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault">G</span></span></span></span>进行拓扑排序，得到拓扑序列</li>
<li><strong>以拓扑序列为阶段，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>求关键路径</strong></li>
</ol>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1570"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1570</mn></mrow><annotation encoding="application/x-tex">1570</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">7</span><span class="mord">0</span></span></span></span> 工厂的烦恼</a><br>
（仍然没有找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">orz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>）</p>
<h4 id="description-8"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Description</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>某工厂发现厂里的机器在生产产品时要消耗大量的原材料，也就是说，有大量的原材料变成了废物。因此厂里想找出消耗原材料最大的一条生产线路进行改造，以降低成本。厂里的生产线路是一个有向无环网络，有N台机器分别代表网络中的N个结点。弧&lt; I,j &gt;(i &lt; j)表示原材料从机器i传输到机器j的损耗数量。
</code></pre>
<h4 id="input-8"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>文件的第一行为N，第二行至第N+1行为N*N的矩阵（若第I行第J列为1，则奸细I能将消息直接传递给奸细J，若第I行第J列为0，则奸细I不能将消息直接传递给奸细J）。
</code></pre>
<h4 id="output-8"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>输出文件只有一行：即我们的郭嘉大大首先至少要传递的奸细个数。
</code></pre>
<h4 id="sample-input-8"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>8
0 0 1 0 0 0 0 0 
1 0 0 1 0 0 0 0 
0 1 0 1 1 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 1 0 0 0 0 
0 0 0 1 0 0 0 0 
0 0 0 1 0 0 0 1
0 0 0 0 0 0 1 0

</code></pre>
<h4 id="sample-output-8"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>2
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
#define inf 0x7fffffff/2
using namespace std;

int bein[maxn];
int a[maxn];
int f[maxn]; //f[a[i]]表示到达顶点a[i]的最长路径
int in[maxn][maxn];
int n,m;

void Topsort() //拓扑排序，不解释，详细内容本博客开头有介绍
{
	int j;
	for(int i=1;i&lt;=n;i++)
	{
		j=1;
		while((j&lt;=n)&amp;&amp;(bein[j]!=0)) j++;
		bein[j]=inf;
		a[i]=j;
		for(int k=1;k&lt;=n;k++)
			if(in[j][k]) bein[k]--;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		in[x][y]=v;
		bein[y]++;
	} //配合拓扑排序及符合题意的输入，不解释
	Topsort();
	for(int i=2;i&lt;=n;i++) //以拓扑序列为阶段
		for(int j=1;j&lt;=i-1;j++)
			f[a[i]]=max(in[a[j]][a[i]]+f[a[j]],f[a[i]]); //DP求关键路径	
	cout&lt;&lt;f[a[n]]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h2 id="差分约束系统">差分约束系统</h2>
<p>像这样一类问题：给定一组不等式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>x</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>c</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x[i]-x[j]&lt;=c[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>(或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>x</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>c</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x[i]-x[j]&gt;=c[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>)，需要求出满足所有不等式的一组解(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x[1],x[2],…,x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>)。</p>
<p>这类问题实际上是线性规划的一类简单问题。<strong>通常可以用系数矩阵表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>&lt;</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Ax&lt;=C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>(或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>&gt;</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Ax&gt;=C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>),其中系数矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>的每一行里有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，其余元素都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的矩阵，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的矩阵，对应有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个不等式，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个未知数，即该系统为一个有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个未知数、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个约束条件的系统。这就是差分约束系统。</strong></p>
<p>如果一组解(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mo>…</mo><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x[1],x[2],….,x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>)满足给定的不等式组，那么(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mo>…</mo><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x[1]+a,x[2]+a,….,x[n]+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>)也能够满足，<strong>所以这类问题的解不唯一</strong>。实际问题中通常对输出的解有一些特别的要求。</p>
<p><strong>自己的一些零碎总结</strong>：</p>
<ul>
<li>
<p>差分约束系统将题目中的约束条件不等式（即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+w(x,t)&gt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+w(x,t)&lt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>之类）转换为图论的单源最短路问题。</p>
</li>
<li>
<p>当不等式是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+w(x,t)&gt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>时，求最短路；当题目不等式是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+w(x,t)&lt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>时，求最长路。</p>
</li>
<li>
<p>有负权回路的有向图不存在最短路径，即无解。</p>
</li>
<li>
<p>注意建边时是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>建边，其原因是不等式。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P1260"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1595</mn></mrow><annotation encoding="application/x-tex">1595</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">9</span><span class="mord">5</span></span></span></span> 工程规划<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1252</mn></mrow><annotation encoding="application/x-tex">1252</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mord">2</span></span></span></span></a></p>
<h4 id="decision"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Decision</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></h4>
<pre><code>　　造一栋大楼是一项艰巨的工程，它是有n个子任务构成的，给它们分别编号1,2,3,....,n(5&lt;=n&lt;=1000)．由于对一些任务的起始条件有着严格地限制，所以每个任务的起始时间T1,T2,T3....,Tn并不是很容易确定的（但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动）．例如：挖掘完成后，紧接着就要打地基；但是混泥土浇筑完成后，却要等待一段时间再去掉模板．
　　这种要求就可以用m（5&lt;=m&lt;=5000）个不等式表示，不等式形如ti-tj&lt;=B代表i和j的起始时间必须满足的条件．每个不等式的右边都是一个常数Ｂ，这些常数可能不相同，但是它们都在区间(-100,100)内．
　　你的任务就是写一个程序，当给定像上面那样的不等式后，找出一种可能的起始时间序列T1,T2,T3....,Tn，或者判断问题无解．对于有解的情况，要使最早进行的哪个任务和整个工程的起始时间，也就是说，T1,T2,T3....,Tn中至少有一个0．
</code></pre>
<h4 id="input-9"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>第一行是用空格分开的两个正整数Ｎ和Ｍ，下面的Ｍ行每行有三个用空格分开的整数i,j,B对应着不等式ti-tj&lt;=B．
</code></pre>
<h4 id="output-9"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>　　如果有可行的方案，那么输出Ｎ行，每行都有一个非负整数且至少有一个0，按照顺序表示每个任务的起始时间．如果没有可行的方案，就输出信息NO SOLUTION．
</code></pre>
<h4 id="sample-input-9"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>5 8
1 2 0 
1 5 -1
2 5 1
3 1 5
4 1 4
4 3 -1
5 3 -3
5 4 -3
</code></pre>
<h4 id="sample-output-9"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Sample</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></h4>
<pre><code>0
2
5
4
1
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;

#define maxn 5005
using namespace std;

struct sj {
	int to,next,w;
} a[maxn&lt;&lt;1]; //前向星结构体数组

int kk,inf,n,m,cnt[maxn],flag;
int head[maxn],size;
int v[maxn],dis[maxn];
int fag;

void AddEdge(int x,int y,int z) {
	a[++size].to=y;
	a[size].next=head[x];
	head[x]=size;
	a[size].w=z;
} //前向星建边操作

void SPFA(int s) { //普通SPFA跑一遍，不解释，详细介绍前面有
	queue&lt;int&gt;q;
	q.push(s);
	dis[s]=0;
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		cnt[x]++;
		if(cnt[x]&gt;n) {
			cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;
			fag=1;
			return ;
		}
		for(int i=head[x]; i; i=a[i].next) {
			int tt=a[i].to;
			if(dis[tt]&gt;dis[x]+a[i].w) {
				dis[tt]=dis[x]+a[i].w;
				if(!v[tt])
					q.push(tt),v[tt]=1;
			}
		}
		v[x]=0;
	}
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1; i&lt;=m; i++) {
		int x,y,z;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		AddEdge(y,x,z); //一定注意，是y向x连边
	}
	memset(dis,127,sizeof(dis));
	for(int i=1; i&lt;=n; i++) { //构建虚拟超级源点，所有边都连上
		AddEdge(0,i,0);
	}
	SPFA(0);
	if(!fag) {
		for(int i=1; i&lt;=n; i++)
			kk=min(kk,dis[i]); //寻找最小值
		for(int i=1; i&lt;=n; i++)
			printf(&quot;%d\n&quot;,dis[i]-kk);
	}
	return 0;
}
</code></pre>
<hr>
<h2 id="后记-by-2020年3月31日205048">后记 by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020</mn><mi mathvariant="normal">年</mi><mn>3</mn><mi mathvariant="normal">月</mi><mn>31</mn><mi mathvariant="normal">日</mi><mn>20</mn><mo>:</mo><mn>50</mn><mo>:</mo><mn>48</mn></mrow><annotation encoding="application/x-tex">2020年3月31日20:50:48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord cjk_fallback">年</span><span class="mord">3</span><span class="mord cjk_fallback">月</span><span class="mord">3</span><span class="mord">1</span><span class="mord cjk_fallback">日</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">8</span></span></span></span></h2>
<p>由于时间仓促，后面的代码等内容可能没有前面详尽。当然，本蒟蒻在写作过程中肯定有不对之处，还希望大佬们广泛地提出问题，以便我和大家更好的知识掌握。</p>
<p>感谢您的认真观看！</p>
<hr>
<h2 id="后记-by-2020年5月6日224811">后记 by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020</mn><mi mathvariant="normal">年</mi><mn>5</mn><mi mathvariant="normal">月</mi><mn>6</mn><mi mathvariant="normal">日</mi><mn>22</mn><mo>:</mo><mn>48</mn><mo>:</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">2020年5月6日22:48:11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord cjk_fallback">年</span><span class="mord">5</span><span class="mord cjk_fallback">月</span><span class="mord">6</span><span class="mord cjk_fallback">日</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span></h2>
<p>在写作完毕过后自己曾经打印了这份博客作为复习资料，发现里面很多生搬的概念，完全起不到吸收知识的作用。于是乎，我决定慢慢的，从今天起，一点一点润色这篇博客，争取让里面90%的东西都是自己的所思所想。</p>
<p>经过一场考试，抱灵的成绩让我更加意识到了自己吸收知识的重要性……<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo separator="true">,</mo><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi><mi>n</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Fine,good night.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord">.</span></span></span></span></p>
<hr>
<h2 id="后记-by-2020年7月12日220237">后记 by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2020</mn><mi mathvariant="normal">年</mi><mn>7</mn><mi mathvariant="normal">月</mi><mn>12</mn><mi mathvariant="normal">日</mi><mn>22</mn><mo>:</mo><mn>02</mn><mo>:</mo><mn>37</mn></mrow><annotation encoding="application/x-tex">2020年7月12日22:02:37</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord cjk_fallback">年</span><span class="mord">7</span><span class="mord cjk_fallback">月</span><span class="mord">1</span><span class="mord">2</span><span class="mord cjk_fallback">日</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">7</span></span></span></span></h2>
<p>期末考试因为寒假没有好好学，最好成绩全年级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span></span></span></span>名的我，三个主科有两个没有上全年级前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>800</mn></mrow><annotation encoding="application/x-tex">800</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。<br>
竞赛这边也要进行分班考试了，可能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>300</mn></mrow><annotation encoding="application/x-tex">300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span>个人就带走<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>60</mn></mrow><annotation encoding="application/x-tex">60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span>个，还要文化课竞赛课双过关才能进班，没戏了。</p>
<p>没戏了，所有都没戏了，自己一个人自以为是的游戏也应该结束了。<br>
颓废的我，水时间的我，垃圾的我，是时候被大浪淘去了。<br>
我已经习惯了被骂了，习惯了拾起信心，改过自新，又被自己打倒了。我就是生活的痞子，什么都无所谓了。大概只有被人嘲笑，求而不得，缴纳学费的时候，才会有一点痛苦。我已经找不到改过自新的方法了。也许就不该再存在了吧。</p>
<p>希望以后还能和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">OI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>、信息学科微笑着招手吧。剩下的块、关键路径和差分约束系统可能不会再完善了吧；这篇文章开头“备忘录”里的事大概也不会做了；存在我博客编辑器里那些未公开的文章，大概不会被看到这行字的你看见了吧。</p>
<p>明明没有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>F</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">AFO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>，却已经做好<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>F</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">AFO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>的觉悟了呢。毕竟这就是现实啊。微笑着接受吧。</p>
<p>感谢你看到这里，忍受我这么多的废话。祝你有自己想要的未来，祝你能得到你想得到的，祝你能天天看见你想看见的人，祝你能幸福永远，祝你永远不会成为我。</p>
<p>晚安，再次感谢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【特辑】Mom，Happy Birthday！彩虹屁沙雕小故事！]]></title>
        <id>https://MrContinue.github.io/post/te-ji-mom-happy-birthday/</id>
        <link href="https://MrContinue.github.io/post/te-ji-mom-happy-birthday/">
        </link>
        <updated>2020-04-25T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://MrContinue.github.io/post-images/1587727305260.jpg" alt="" loading="lazy"><br>
文心悦同学画的生日贺图哦qwq</p>
<h2 id="晚安篇">💘晚安篇</h2>
<p><code>晚安，我美丽的mom</code></p>
<p>很久很久以前，传说有一个充满着头秃的国家……科科，我们就暂且叫它头秃国吧。</p>
<p>头秃国的城堡里有三个欢乐的人儿，他们分别是，国王、皇后。And their handsome child，我们暂且叫她continue吧。很明显，三个人当中，只有美丽的皇后才避免了头秃的命运，所以时常，皇后在城堡里是不用电灯泡的，毕竟有国王光蹭蹭的大光头。国王不在的时候，continue就会用她快要到后脑勺的帅气额头发光。</p>
<p>别的国家出行时是必有乐队相伴的，奈何国王和皇后一直都恩恩爱爱，每次出行几乎都会奏响魅力的语言进行曲，使路上的气氛顿时活跃起来。这时候，continue总会把她帅气的眉头皱一皱，并且专注于膜法的学习，以假装听不见这样美丽的文字对话。<br>
But 有时候，continue也会加入这场美丽的大合奏，并最终恰似狠狠的拉下最洪亮的大提琴，结束这场华丽语言美丽show的演奏。</p>
<p>当然，这样华丽的演奏不是天天能进行的，但是国王夫妻俩对语言魅力的痴迷，使得他们时常冷不防的就会奏响轻松的一曲，这对他们来说可谓是家常便饭。</p>
<p>除了夫妻二重奏以及continue的和声伴奏以外，头秃国的生活都是那么的平静。</p>
<p>很快，continue长大了。帅气的她决定走上学习膜法的路。可是很明显，她学习的这个膜法并不符合大家对一个文艺帅小伙的看法。<br>
为什么呢？<br>
因为本来学习膜法的人就是少之又少，而continue想要学习的膜法更是很少有像她这样的帅小伙学习。这使得她有一丝er丝er的苦恼——她非常担心自己所处的环境是一个封建的极权主义家庭，从而断掉了自己的膜法之路。</p>
<p>但是事实总是偏向主角这一方，国王和皇后非常果断的认可了continue的膜法学习梦想，决定之果断甚至让continue都怀疑是不是国王皇后夫妻二人的童心未泯。But 事实证明，这并非玩笑话。国王和皇后非常支持continue的所有符合价值观的梦想。</p>
<p>这让continue受到了极大的鼓舞。于是乎，她踏上了学习膜法的征程。</p>
<p>……</p>
<p>很快，时间过去。continue一天天变帅，国王一天天变秃，皇后一天天变美。<br>
城墙什么时候又翻了新？帅小伙的贴身侍卫的身上何时有多了几处伤？国王和皇后的脸上，怎么又出现了奇奇怪怪的小沟渠？</p>
<p>转眼间，皇后的生日到了。<br>
除了帅小伙continue和国王，没有人知道美丽的皇后的真实年龄，大家都看不出来她年轻的颜容下究竟有多少的经历，大家知道的是，今天是一个无比开心的日子，因为今天是皇后的生日。</p>
<p>帅小伙的膜法入门了，国王的头秃又上升到了至臻的境界，邻国的公主成了大家闺秀，而她的家庭在这个幸福的日子也前来祝福了。</p>
<p>窗前的鸟开始欢快的歌颂头秃国一家三口的幸福与美满；门口的树开始发新芽，以勃勃的生机祝福美丽的皇后容颜不老；天上的云也故意垂下来，给自己的脸庞上铺一点鲜活的淡粉色粉底，只是为了祝福皇后永远的可爱与皇后一家永远的长久……</p>
<p>在这个幸福的日子里，皇后必须是最幸福的人儿。</p>
<p>到了晚上，月亮藏在云里，却也轻轻念着祝福的话语；风轻轻的拂过树枝，拉起轻柔的夜曲。一切都是轻轻柔柔的，恰成为美丽皇后的安眠旋律。</p>
<p><strong>晚安啦，美丽的皇后，祝你生日快乐。</strong><br>
❤️💛💚💙💜</p>
<hr>
<h2 id="圆月篇">💖圆月篇</h2>
<p><code>圆月，团圆，和和睦睦的一家人</code></p>
<p>continue对她美丽的母亲有着怎样的印象呢？</p>
<p>continue：“Oh，我亲爱的姑娘，她是一位怎样的仙女，我可真不敢相信这世界上还有谁不清楚的！她真像高山上的一朵小花儿上的露珠！Oh，我的上帝！世间还有比这位仙女更加迷人的姑娘吗？“</p>
<p>（导演：口区）<br>
（导演：正常点，刚才的剪掉重新来）</p>
<p>continue对她美丽的母亲有着怎样的印象呢？</p>
<p>continue：“美丽的母亲唷，好像一位仙女，世上没有人不知道她的美貌。美丽的母亲唷，我听说她的美貌胜似花上的露珠，百万光年内也找不出比她更美丽的。悲夫！世界总是这样的啊！难道这世上还有比她更美丽的姑娘吗？”</p>
<p>（导演：感觉怪怪的，但是就这段了吧）<br>
嘻嘻。</p>
<p>头秃国国王对他美丽的妻子有着怎样的印象呢？<br>
（打字太累了，干脆简称头秃国国王为秃王吧！）</p>
<p>秃王：“吃得多，喜欢睡觉，吃得多了过后睡觉。”</p>
<p>（快给导演一颗速效救心丸！！）<br>
（剪掉了上面这一段，重新来）</p>
<p>头秃国国王对他美丽的妻子有着怎样的印象呢？<br>
（打字太累了，干脆简称头秃国国王为秃王吧！）</p>
<p>秃王：“吃得多，喜……”</p>
<p>（导演怨恨的眼神）</p>
<p>秃王：“……欢做饭，做的饭可好吃了，比外面的好吃多了，有着浓浓的家的味道，我觉得这样美丽贤惠的姑娘能看上我真是三生有幸！”</p>
<p>（秃王辛苦了）</p>
<p>窗边的小树觉得皇后很赞，天上的云朵觉得皇后很赞，everybody都觉得皇后很赞。</p>
<p><strong>因为这是世界上最可爱的人啊QwQ</strong><br>
❤️💛💚💙💜</p>
<hr>
<h2 id="彩虹篇">💓彩虹篇</h2>
<p><code>每个人都有自己的兴趣和爱好，就像彩虹一样，彩虹上的每种颜色都是不一样的</code></p>
<h3 id="喜欢的颜色篇">喜欢的颜色篇</h3>
<p>听说皇后喜欢粉色呢。continue如是想道。</p>
<p>为什么我就不喜欢呢？喜欢蓝色的continue又如是想道。</p>
<p>哦，想起来了。<br>
年纪越大，越喜欢粉红色的东西。<br>
<img src="https://MrContinue.github.io/post-images/1587197376832.jpg" alt="" loading="lazy"></p>
<p>get√</p>
<h3 id="喜欢的动物篇">喜欢的动物篇</h3>
<p>听说皇后喜欢狗狗呢。continue如是想道。</p>
<p>为什么我就不喜欢呢？喜欢龙狮子猎豹也喜欢金鱼和猫的continue又如是想道。</p>
<p>哦，想起来了。<br>
我是属狗的。</p>
<h3 id="博物馆失火救猫还是救画">博物馆失火，救猫还是救画？</h3>
<p>听说皇后选的是救猫呢。continue如是想道。</p>
<p>为什么我就不想救猫呢？想救画的continue又如是想道。</p>
<p>哦，想起来了。<br>
毕竟皇后超级的友善呢。<br>
❤️💛💚💙💜</p>
<hr>
<h2 id="小剧场">小剧场</h2>
<p><code>为了凑字数出现的小剧场（×）拍摄小花絮（√）</code></p>
<h3 id="花絮1">花絮1</h3>
<p>两周前。<br>
continue开始疯狂揉搓她那所剩无几的头发。这一方面是因为她肝不出来的信竞总结，更是因为mom的生日即将到来，而continue还没有准备礼物。</p>
<p>她晃荡了一下脑子，听见了里面的水碰撞大脑壁的声音。</p>
<p>突然，她被这个美妙的声音所启发！</p>
<p>不必重复以往的手作贺卡，写一份沙雕小故事给美（沙）丽（雕）的mom也是一份很有新意的礼物！<br>
（虽然不知道是怎么被启发的，但是写就vans了）</p>
<p>于是乎，键盘侠（bushi）continue利用她唯一的特长：打字比家里的金鱼快这一点，开始编写了她沙（神）雕（经）的小故事。</p>
<p>写到这里的时候，她的头发又已经少了20+根了。</p>
<h3 id="花絮2">花絮2</h3>
<p>开工后。<br>
continue居然还写出了一份（并没有卵用的）信竞总结！这让她感到开心与欢乐！<br>
（这个算个什么花絮？？）</p>
<h3 id="花絮3">花絮3</h3>
<p>continue的彩虹屁技巧增加了！<br>
（奇怪的技巧增加了！.jpg）</p>
<hr>
<p>总之，最最美丽的mom。生日快乐！<br>
❤️💛💚💙💜</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整理】启发式搜索模板题及知识点汇讲]]></title>
        <id>https://MrContinue.github.io/post/zheng-li-qi-fa-shi-sou-suo-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/</id>
        <link href="https://MrContinue.github.io/post/zheng-li-qi-fa-shi-sou-suo-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/">
        </link>
        <updated>2020-04-21T13:20:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="阅前必读">阅前必读</h2>
<p>本博客纯手写，无借鉴，请大胆的提意见哦QwQ</p>
<hr>
<h2 id="优先队列bfs">优先队列BFS</h2>
<h3 id="回顾普通bfsbfs普通队列">回顾普通BFS——BFS+普通队列</h3>
<h4 id="bfs是什么">BFS是什么</h4>
<p>BFS，宽度优先搜索。<br>
它的搜索方式就像涟漪一样，是<strong>一层一层</strong>遍历下去。具体见下图：<br>
<img src="https://MrContinue.github.io/post-images/1587480080689.png" alt="" loading="lazy"><br>
cnt表示遍历的层次。</p>
<p>所谓“涟漪式”的遍历，其实就是<strong>以层次的不断向目标状态展开，对图中每一个点的最优值更新，从而达到遍历至目标状态时的最优值。</strong></p>
<h4 id="bfs可以干什么">BFS可以干什么？</h4>
<p>一般出现<strong>最短路径</strong>和<strong>最佳方案</strong>时可以使用BFS遍历。</p>
<h4 id="bfs普通队列怎么写">BFS+普通队列怎么写？</h4>
<p>下面是伪代码：</p>
<pre><code>void BFS(int x)
{
        初始化队列Q;
        标记x已遍历;
        Q.push(x);
        while(!Q.empty())
        {
                int u=Q.top();
                Q.pop();
                if(u==目标状态)
                {
                      ……
                }
                Q.push(与u相连的未被访问的所有点);
                标记u已遍历;
        }
}
</code></pre>
<p>注：BFS+普通队列对应的是<strong>SPFA算法</strong>。</p>
<h3 id="学习优化bfsbfs优先队列">学习优化BFS——BFS+优先队列</h3>
<p>优化BFS算法采用<strong>Dijkstra堆优化的方式求解</strong>。<br>
注：BFS+优先队列对应的是<strong>Dijkstra算法</strong>。</p>
<h4 id="dijkstra简单回顾">Dijkstra简单回顾</h4>
<p>从源点开始向自己的子节点扩展，将已拓展到的子节点对应的边权加入数组d当中，再在数组d当中选取一个最小值，从这个值对应的节点开始继续向下搜索。</p>
<p>值得一提的是，Dijkstra中，d数组里储存的“边权”是相对于源点来说的。<br>
还没有回忆起来？这张图也许能帮到你：<br>
<img src="https://MrContinue.github.io/post-images/1587567326814.png" alt="" loading="lazy"></p>
<h5 id="dijkstra代码简单回顾">Dijkstra代码简单回顾</h5>
<pre><code>void D()
{
	for(int i=1;i&lt;=n;i++)
		a[i]=inf; //初始化
	int k;
	a[s]=0; //第一个节点（即根节点）距离根节点（即自己）的距离为0
	prt[s]=0; //第一个节点的父亲定义为0
	for(int i=1;i&lt;=n;i++)
	{
		int minn=inf; //找最小边权
		for(int j=1;j&lt;=n;j++)
			if(!vis[j]) //如果未访问过
				if(a[j]&lt;minn) //且此边权小于当前最小边权
				{
					minn=a[j]; //则更新最小边权
					k=j; //记录此节点
				}
		vis[k]=1; //访问该节点
		for(int j=1;j&lt;=n;j++)
			if(g[k][j]&gt;0&amp;&amp;!vis[j]) //更新与该节点有连接的点的边权值
				if(a[k]+g[k][j]&lt;a[j]) //松弛操作
				{
					a[j]=a[k]+g[k][j];
					prt[j]=k; //记录更新它的值的节点
				}
	}
}
</code></pre>
<p>而在寻找d数组里的最小值时需要O(n)的复杂度，所以我们期望有一种方法可以降低寻找最小值的复杂度。<br>
由于优先队列的最优性质，我们可以用堆优化Dijkstra。</p>
<h4 id="我们怎么用堆优化dijkstra">我们怎么用堆优化Dijkstra？</h4>
<p>前文提到过堆的用途。所以我们只需要将每次的边权push到堆里，每次取出时就不需要用O(n)的时间来寻找最小值了，直接取堆顶即可。<br>
关于堆，它查询的复杂度是O(1)，处理节点（插入、删除等）的复杂度为O(logn)。</p>
<h4 id="堆优化dijkstra的细节">堆优化Dijkstra的细节</h4>
<p>我们在写普通Dijkstra的时候会用到节点的序号，但是我们在用堆优化的时候暂时无法自定义堆自己维护时的规则，所以这个时候我们需要运用<strong>重载运算符</strong>。</p>
<h5 id="重载运算符">重载运算符</h5>
<p>先丢一段模板代码，接着我们再来慢慢分析：</p>
<pre><code>struct Heap
{
	int d,num;
	bool operator &lt; (const Heap&amp; a)const
	{
		return d&gt;a.d;
	}
};
</code></pre>
<p>在结构体Heap中，先定义了两个变量d和num，紧接着是重载运算符的函数。</p>
<h6 id="关于各个部分的细节分析">关于各个部分的细节分析</h6>
<p>函数的类型是<strong>bool</strong>，大致概念可以联系sort里的cmp函数进行理解。</p>
<p>关于<strong>operator</strong>是判断重载运算符的一个标志，英文释义有“操作人员;技工;电话员;接线员;(某企业的)经营者，专业公司”等释义，放在这里大致可以理解为<strong>进行操作的东西</strong>。</p>
<p><strong>const Heap&amp; a</strong>相当于定义了一个Heap类型的变量a，方便等会我们括号内的比较操作。</p>
<p>括号内的内容可以与sort里的cmp函数类比，差不多一个概念，只不过这里的第二个比较数是通过Heap类型的变量a引用的。</p>
<p><strong>和一个函数一样，重载运算符是必须要用一对花括号扩上的。</strong></p>
<p>重载运算符成功过后，堆对自己的维护就可以根据结构体内的定义进行操作。</p>
<h4 id="关于堆优化重载运算符的注意事项">关于堆优化重载运算符的注意事项</h4>
<p><strong>非常重要的是，当我们在重载运算符时，return时的符号应该与想得到的最值符号相反。</strong><br>
也就是说，如果想得到a和b中的最大值，反而需要用return a＜b；同样，如果想要得到a、b之中的最小值，则需要return a&gt;b。</p>
<p>其原因可以看下图理解一下。<br>
<img src="https://MrContinue.github.io/post-images/1587729088405.png" alt="" loading="lazy"></p>
<h3 id="题目代码理解">题目+代码理解</h3>
<p><a href="https://www.luogu.com.cn/problem/P1828">香甜的黄油</a></p>
<h4 id="description">Description</h4>
<pre><code>农夫John发现做出全威斯康辛州最甜的黄油的方法：糖。把糖放在一片牧场上，他知道N（1&lt;=N&lt;=500）只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。当然，他将付出额外的费用在奶牛上。
农夫John很狡猾。像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。
农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。
</code></pre>
<h4 id="input">Input</h4>
<pre><code>第一行: 三个数：奶牛数N，牧场数P（2&lt;=P&lt;=800），牧场间道路数C(1&lt;=C&lt;=1450)。
第二行到第N+1行: 1到N头奶牛所在的牧场号。
第N+2行到第N+C+1行：每行有三个数：相连的牧场A、B，两牧场间距（1&lt;=D&lt;=255），当然，连接是双向的。
</code></pre>
<h4 id="output">Output</h4>
<pre><code>一行 输出奶牛必须行走的最小的距离和。
</code></pre>
<h4 id="sample-input">Sample Input</h4>
<pre><code>3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
</code></pre>
<h4 id="sample-output">Sample Output</h4>
<pre><code>8
</code></pre>
<h4 id="hint">Hint</h4>
<pre><code>说明：放在4号牧场最优。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://oj.bashu.com.cn/images/p1431.gif" alt="" loading="lazy"></figure>
<hr>
<p>因为是求最短路径，<s>又因为SPFA死了</s>，所以我们可以考虑用Dijkstra枚举求解，大概思路就是枚举放在每个节点的路径长度，最后择取最小的一条。<br>
但是很明显，普通的Dijkstra会T掉，所以我们考虑使用堆优化Dijkstra，这样就可以愉快的枚举了。</p>
<p>贴代码，具体的细节和部分知识解释都放在代码注释里了：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

#define maxn 1465
#define inf 0x7fffffff/2
using namespace std;

int dis[maxn];
int head[maxn+10],cnt;
int e,n,m;
int k=inf;
int s,t;

int cow[maxn];

inline int Read() //快读模板
//对快读感兴趣的同学可以看看我对快读讲解的小短文
//链接：https://mrcontinue.xyz/post/zheng-li-shou-xie-kuai-du-mo-ban-ji-jian-dan-fen-xi/
{
	int s=0;
	int f=1;
	char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9')
	{
		if(ch=='-')
			f==-1;
		ch=getchar();
	}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')
	{
		s=(s&lt;&lt;1)+(s&lt;&lt;3)+ch-'0';
		ch=getchar();
	}
	return s*f;
}

struct Edge
{
	int to,next,w;
}a[maxn&lt;&lt;1]; //前向星数组，w用于存边权

struct Heap
{
	int d,num; //变量d用来储存变量本身的数值，变量num用来储存变量的序号
	bool operator &lt; (const Heap&amp; rhs)const
	{
		return d&gt;rhs.d;
	} //重载运算符
}; //我们之前花了大量的笔墨来讲解的堆优化结构体

void AddEdge(int x,int y,int v) //前向星连边操作
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	a[cnt].w=v;
	head[x]=cnt;
}

bool vis[maxn]; //记录是否被访问
int d[maxn]; //d[i]记录节点i离源点的距离

int Dij(int x)
{
	priority_queue &lt;Heap&gt; Q; //定义一个储存节点的堆Q
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=n;i++)
		d[i]=inf; //Dijkstra日常操作
	d[x]=0;
	Q.push((Heap){ d[x],x }); //将当前节点的序号和值push到堆里面
	while(!Q.empty()) //一直遍历到堆为空，也就是所有节点遍历完毕
	{
		Heap u=Q.top(); //先取出堆顶的二元组，也就是当前数值最小的元素
		Q.pop();
		int s=u.num; //取出当前节点的序号，方便以下开始遍历
		if(vis[s]) continue; //如果已经遍历过该节点，则跳过此次遍历
		vis[s]=1; //标记已经遍历
		for(int i=head[s];i;i=a[i].next)
		{
			int y=a[i].to; //遍历边sy
			if(!vis[y] &amp;&amp; d[s]+a[i].w&lt;d[y]) //Dijkstra松弛操作
			{
				d[y]=d[s]+a[i].w;
				Q.push((Heap){ d[y],y }); //将新的二元组放入堆中
			}
		}
	}
	int ans=0;
	for(int i=1;i&lt;=e;i++)
		ans+=d[cow[i]];
	return ans;
}
	
int main()
{
	e=Read();
	n=Read();
	m=Read();
	for(int i=1;i&lt;=e;i++)
		cow[i]=Read(); 
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		x=Read();
		y=Read();
		v=Read();
		AddEdge(x,y,v);
		AddEdge(y,x,v); //建边操作
	}
	for(int i=1;i&lt;=n;i++)
		k=min(k,Dij(i));
	printf(&quot;%d\n&quot;,k);
	return 0;
}
</code></pre>
<hr>
<h2 id="a">A*</h2>
<h3 id="为什么需要a">为什么需要A*？</h3>
<p>在有些时候，遍历最优方案时可能会低效率。比如当最佳方案在最后的时候。<br>
所以我们可以考虑，编写一个<strong>能估价的函数</strong>，如果能先一步估价出后来的大致数值，那么最优解就可以更快的被遍历出来。</p>
<p>而A*就具备可以估价的特点。</p>
<h3 id="估价函数需要满足些什么">估价函数需要满足些什么？</h3>
<p>大体上来讲，估价函数是为了提前获取最佳路线而产生的，所以它需要满足：<br>
<code>估价函数的估值不能大于未来实际代价，估价应比实际代价更优。</code></p>
<p>这样它才能做到不错判未来的实际价值大小。</p>
<h4 id="为什么必须要估小才不会错判">为什么必须要估小才不会错判？</h4>
<h5 id="文字上的解释-奇怪的比喻">文字上的解释 &amp;&amp; 奇怪的比喻</h5>
<p>从理论上来讲，如果要求最佳值，那么我们的估价函数必须要符合“最佳”这一点，也就是说，它的结果值应该是“最佳的”。而估价函数的值往往与事实会有偏。，所以为了让我们根据估价函数值所得出的继续发展的大方向不会出现错误，我们尽量让估价函数的估值比实际“最优值”再“更优”一点。</p>
<p><strong>打个奇怪的比方</strong>，小学的时候我们可能见过这样的题目：<br>
<code>did有10块钱，问你他可不可以同时购买一个2.5的东西和一个4.5的东西</code></p>
<p>这个时候我们自然而然的就会把2.5当做3，4.5当做5，发现3+5=8&lt;10，说明did可以同时买到这两样东西。<br>
那个时候我的数学老师是这么说的：“多估都够，实际更行。”</p>
<p>这是一个道理。</p>
<h5 id="一个例子-实例证明">一个例子 &amp;&amp; 实例证明</h5>
<p>本图来源于《算法竞赛进阶指南》<br>
<img src="https://MrContinue.github.io/post-images/1588389478208.png" alt="" loading="lazy"></p>
<p>所以我们也可以大概知道估价函数的大体工作方式：<strong>从任意一个状态作为起点，计算出当前状态需要的估价值，接着不断从堆里取出“当前代价+估价”最小的节点进行遍历</strong>。</p>
<h3 id="a到底是什么">A*到底是什么？</h3>
<p>综上，我们可以发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">∗</span></span></span></span>其实就是<strong>带有估价函数的优先队列BFS</strong>（至于为什么是<strong>优先队列BFS</strong>而不是其他的，从估价函数的工作方式就能略知一二）。如果估价始终为0，那么就等价于普通的BFS。</p>
<p>只讲概念可能有点生涩，下面我们结合模板题来理解一下。</p>
<h3 id="题目思路整理">题目思路整理</h3>
<p><a href="https://www.luogu.com.cn/problem/P4467">k短路</a></p>
<h4 id="题目描述">题目描述</h4>
<p>有n个城市和m条单向道路，城市编号为1到n。每条道路连接两个不同的城市，且任意两条道路要么起点不同要么终点不同，因此n和m满足m≤n(n−1)。</p>
<p>给定两个城市a和b，可以给a到b的所有简单路（所有城市最多经过一次，包括起点和终点）排序：先按长度从小到大排序，长度相同时按照字典序从小到大排序。你的任务是求出a到b的第k短路。</p>
<h4 id="输入格式">输入格式</h4>
<p>输入第一行包含五个正整数n，m，k，a，b。</p>
<p>以下m行每行三个整数 u，v，l，表示从城市u到城市v有一条长度为l的单向道路。</p>
<h4 id="输出格式">输出格式</h4>
<p>如果a到b的简单路不足k条，输出No，否则输出第k短路：从城市开始依次输出每个到达的城市，直到城市b，中间用减号-分割。</p>
<h4 id="输入输出样例">输入输出样例</h4>
<h5 id="输入-1">输入 #1</h5>
<pre><code>5 20 10 1 5
1 2 1
1 3 2
1 4 1
1 5 3
2 1 1
2 3 1
2 4 2
2 5 2
3 1 1
3 2 2
3 4 1
3 5 1
4 1 1
4 2 1
4 3 1
4 5 2
5 1 1
5 2 1
5 3 1
5 4 1
</code></pre>
<h5 id="输出-1">输出 #1</h5>
<pre><code>1-2-4-3-5
</code></pre>
<h5 id="输入-2">输入 #2</h5>
<pre><code>4 6 1 1 4
2 4 2
1 3 2
1 2 1
1 4 3
2 3 1
3 4 1
</code></pre>
<h5 id="输出-2">输出 #2</h5>
<pre><code>1-2-3-4
</code></pre>
<h5 id="输入-3">输入 #3</h5>
<pre><code>3 3 5 1 3
1 2 1
2 3 1
1 3 1
</code></pre>
<h5 id="输出-3">输出 #3</h5>
<pre><code>No
</code></pre>
<h4 id="说明提示">说明/提示</h4>
<pre><code>第一个例子有5个城市，所有可能出现的道路均存在。从城市1到城市5一共有5条简单路，排序如下：
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/pic/17706.png" alt="" loading="lazy"></figure>
<pre><code>20%的数据满足：n≤5。
40%的数据满足：n≤30。
100%的数据满足：2≤n≤50，1≤k≤200。
</code></pre>
<hr>
<h3 id="简单分析">简单分析</h3>
<p>k短路是A*的经典例题。<br>
上面我们介绍的优先队列BFS中，<strong>当一个状态第一次从堆中取出时，就得到了从初态到它的最小代价</strong>，所以我们可以由此推出：当一个储存着一个节点信息的二元组(d[x],x)第k次从堆中取出时，它就是一条成熟的k短路了。<br>
由此我们可以得出，当节点T的二元组(d[T],T)被取出第k次时，我们就可以得到答案了。</p>
<h3 id="估价函数的设计">估价函数的设计</h3>
<p>之前我们分析过，在第k短路中，节点x到终点T的估计距离f(x)不能大于实际距离g(x)。<strong>所以，我们可以把估价函数定为从x到T的当前最短路长度。</strong><br>
这样既不会让f(x)大于g(x)，还可以成功引导第k短路发展的趋势。</p>
<h3 id="大体步骤设计">大体步骤设计</h3>
<ol>
<li>初始化各个节点到终点T的最短路f(x)，这相当于反着求一遍单源最短路，可以用O((N+M)log(N+M))<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>1</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>的时间完成。   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>1</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>：该数据来源于《算法竞赛进阶指南》</li>
<li>建立一个堆，将所有节点的信息以(dist+f(x),x)的二元组push到里面去（详见前面介绍的堆优化Dijkstra操作），其中dist是从起点S到x当前走过的距离。</li>
<li>取出堆顶，即当前距离值最小的节点，然后沿着和x相关的边xy进行拓展，每次遇见没有遍历到k次的节点y就将(dist+length(x,y),y)的二元组push到堆里。</li>
<li>重复第2、3步直至取出S到T的k短路。</li>
</ol>
<hr>
<p>感谢宁的观看丫QwQ</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【特辑】一篇认真写的博客和赶作业的博客到底有什么区别？]]></title>
        <id>https://MrContinue.github.io/post/te-ji-ren-zhen-xie-de-yi-pian-bo-ke-dao-di-he-gan-zuo-ye-de-bo-ke-you-shi-me-qu-bie/</id>
        <link href="https://MrContinue.github.io/post/te-ji-ren-zhen-xie-de-yi-pian-bo-ke-dao-di-he-gan-zuo-ye-de-bo-ke-you-shi-me-qu-bie/">
        </link>
        <updated>2020-04-19T14:40:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="写作起因">写作起因</h2>
<p>总感觉自己容易咕咕，只有在任务非常非常急的时候才会才会触发被动技能：一日爆肝，于是可以在一个下午之内肝出17000+字。</p>
<p>可是既然大家基本上都有这个被动技能，为什么大佬们的高质量博客总是姗姗来迟呢？</p>
<p>为了探究博客的质量问题，我决定水这一篇文章，并且做一个小小的实验。</p>
<hr>
<h2 id="实验">实验</h2>
<p>准备工具：</p>
<ul>
<li>一个美好的Gridea软件</li>
<li>两只闲来无事的手</li>
<li>一个有着创作热情的大脑</li>
<li>一颗非常平静的心</li>
</ul>
<p>OK，我们现在来看看认真写一篇博客到底是怎样的。</p>
<hr>
<h2 id="实验初回忆">实验初：回忆</h2>
<p>其实我也有认真写过的博客，只是后来貌似咕咕了，但是当时感觉挺好的。所以这次我决定写一篇非常非常认真并且不会咕咕的博客。</p>
<p>这里一直所指的博客是一篇整理报告，在我水现在这篇博客的时候它还离成功差的很远。要是您看到一篇名为“【整理】RMQ模板题及知识点汇讲”的博客了，那就说明我爆肝成功了。</p>
<hr>
<h2 id="实验中对比">实验中：对比</h2>
<h3 id="开始施工">开始施工</h3>
<p>认真的博客：先讲讲自己理解的概念，再对照一下老师的PPT和视频讲解，思想一致，表述的清楚，那我就不会做修改。</p>
<p>并不认真的博客：仍然先是摆概念，但是会觉得自己写概念一是不太标准，二来更是为了节约时间的一个偷懒做法。</p>
<p>由于自己写的概念不一定对，不太清楚的地方还要反复摸索打磨，所以花的时间是2min~2天不等，这与赶作业博客0.1秒的copy慢多了。<br>
但是很明显，前者总结出来化为自己知识的部分更多。在反复打磨的过程中也能留给自己一个更深的印象。</p>
<p><strong>小结：认真的博客显然更有利于知识的吸收。</strong></p>
<h3 id="施工中">施工中</h3>
<p>认真的博客：参考的资料比较广，会看自己学校编的教材，会翻老师的PPT，会回看老师的讲课视频，甚至还会翻开落灰的蓝书和紫书找灵感。大多数时候写出来的东西自己不太确定对不对，就会去问老师。等老师回答后又要进行修改，有的时候还要狠心删掉之前辛辛苦苦写的一大段不太正确的思路，再重新构思。</p>
<p>并不认真的博客：先丢一道模板题的代码，然后在代码里疯狂加注释，心情好的时候会参考老师的PPT和自己学校编的教材做一些额外的批注，有的时候赶时间就没有额外的东西了。</p>
<p>很明显认真的写一篇博客是一件非常耗时的事情。在RMQ总结里问了老师很多东西，也删掉了很多自己好不容易做出来的图片和文字。当然，最后剩下的应该都是那些思想中的精华。我认为这很有意义。</p>
<p><strong>小结：认真的博客提炼的都是精华，更有价值。</strong></p>
<h3 id="施工完毕">施工完毕</h3>
<p>其实还没有全部施工完毕，但是部分施工完毕也有着差不多的感受。</p>
<p>认真的博客：好不容易花3天总结出来的东西只有寥寥201字，正常阅读时长不到50秒，但是总感觉心中踏实了很多，因为我所掌握的知识真的有因为这200字而增加。</p>
<p>并不认真的博客：写完了如释重负，但是回过头来又有好多东西是照搬，自己理解没有也不是清楚，迷迷糊糊的，但是又不想再修改了。</p>
<p><strong>小结：认真的博客才能真正让我达到“总结”的目的，而不是为了完成作业的临时爆肝。</strong></p>
<hr>
<p>综上所述，认真写一篇博客真的非常难，但是它确实能给我带来不一样的知识渗透和幸福的成就感。</p>
<p>感谢观看qwq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整理】手写快读模板及简单分析]]></title>
        <id>https://MrContinue.github.io/post/zheng-li-shou-xie-kuai-du-mo-ban-ji-jian-dan-fen-xi/</id>
        <link href="https://MrContinue.github.io/post/zheng-li-shou-xie-kuai-du-mo-ban-ji-jian-dan-fen-xi/">
        </link>
        <updated>2020-04-17T11:43:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="阅前必读">阅前必读</h2>
<p>这篇小短文仍然是纯手写的自己的想法，有什么不对、不好的地方非常欢迎各位大佬指正qwq！</p>
<hr>
<h2 id="我们为什么要学习手写快读">我们为什么要学习手写快读？</h2>
<ul>
<li>平常读入速度快，写起来比较简单。</li>
<li><strong>在某些特定环境可以不用考虑输入的困难，因为快读只考虑数字</strong></li>
<li>可以瞬间提升代码的B格（大雾）<br>
当然，如果宁并不想敲快读的代码，scanf也是一个不错的选择<br>
（没有冒犯cin的意思，虽然它用起来比较方便，但是它实在是太慢了，一般数据稍微大一点就不要用cin了，容易超时）</li>
</ul>
<hr>
<h2 id="快读的原理及基本过程">快读的原理及基本过程</h2>
<p>快读利用的是C++的getchar()进行读入，也就是说，<strong>输入的每个数字或者字母，都将被当做一个“符号”处理。</strong><br>
接着，快读函数将根据符号和数字进行分类处理，最后返回实际读入的值。</p>
<p>我们一般在快读函数里<strong>只处理数字</strong>，这样在快速读入的情况下可以避免一些奇怪输入的困扰。</p>
<hr>
<h2 id="快读代码模板">快读代码模板</h2>
<p>纯代码版：</p>
<pre><code>inline int Read()
{
    int s=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        s=(s&lt;&lt;1)+(s&lt;&lt;3)+ch-'0';
        ch=getchar();
    }
    return s*f;
}
</code></pre>
<p>注释解析版：</p>
<pre><code>inline int Read()
{
	int s=0; //存数值
	int f=1; //存符号
	char ch=getchar(); //当前读取的字符
    while(!isdigit(ch)) //如果当前读入的字符不是数字
    {
        if(ch=='-') //如果是负号
            f=-1; //则标记这个数为负
        ch=getchar(); //并且继续读取下一个字符
    }
    while(isdigit(ch)) //如果当前读入的字符是数字
    {
        s=(s&lt;&lt;1)+(s&lt;&lt;3)+ch-'0'; //则将值累加到存数值的变量s里面
        ch=getchar(); //并且继续读取下一个字符
    }
    return s*f; //如果t在判断负数时被标记成了-1，那么这个时候数值s与t相乘，直接变为负值
}
</code></pre>
<hr>
<h2 id="一些小问题">一些小问题</h2>
<ol>
<li>
<p>Q：在累加值的时候<code>s=(s&lt;&lt;1)+(s&lt;&lt;3)+ch-'0'</code>中的<code>(s&lt;&lt;1)+(s&lt;&lt;3)</code>是什么意思呢？<br>
A：<code>(s&lt;&lt;1)+(s&lt;&lt;3)</code>就是和<code>s*10</code>一个效果啦，只是在这里运用了快一点的位运算。当然，直接写<code>s*10</code>也不会有什么问题啦qwq</p>
</li>
<li>
<p>Q：啥是isdigit啊？<br>
A：就是一个判断<strong>输入字符串是否为整数</strong>的函数啦，用法就是isdigit(ch)，头文件的话，有iostream就可以编译成功哦qwq</p>
</li>
<li>
<p>Q：为什么不介绍快速输出呢？<br>
A：因为快速输出没有什么特别的需要啊，平常用printf它不香嘛qwq</p>
</li>
</ol>
<hr>
<h3 id="感谢您的观看呀qwq">感谢您的观看呀qwq</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【动漫】弹丸论破——狛枝凪斗]]></title>
        <id>https://MrContinue.github.io/post/dong-man-dan-wan-lun-po-po-zhi-ci-dou/</id>
        <link href="https://MrContinue.github.io/post/dong-man-dan-wan-lun-po-po-zhi-ci-dou/">
        </link>
        <updated>2020-04-15T01:05:36.000Z</updated>
        <content type="html"><![CDATA[<p>狛哥的颜从2016磕到了2020，这是什么神仙？？？<br>
狛枝我真的i了，超吃这种颜的wwwww 这种盛世美颜和这种神仙性格太i了</p>
<p>不说了，直接放图感受一下（来源于网络&amp;&amp;堆糖，侵删）<br>
（狛日太香）<br>
<img src="https://MrContinue.github.io/post-images/1586913463890.jpg" alt="" loading="lazy"><br>
狛哥真的是可爱又帅气，这波我真滴可以<br>
<img src="https://MrContinue.github.io/post-images/1586913482365.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913489923.jpg" alt="" loading="lazy"><br>
超级喜欢这张图滴配色，给人一种很舒服滴感觉<br>
<img src="https://MrContinue.github.io/post-images/1586913497061.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913503567.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913509450.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913555210.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913613120.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913620519.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913628578.jpg" alt="" loading="lazy"><br>
这张滴狛哥真的太可爱了wwwww 幼年狐狸状狛哥可太i了<br>
<img src="https://MrContinue.github.io/post-images/1586913636681.jpg" alt="" loading="lazy"><br>
这张也很i啊啊啊啊啊给人一种很休闲滴感觉wwwww<br>
<img src="https://MrContinue.github.io/post-images/1586913643672.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586913651955.jpg" alt="" loading="lazy"><br>
这张是我滴Windows账号头像，太i了<br>
<img src="https://MrContinue.github.io/post-images/1586914018392.jpg" alt="" loading="lazy"><br>
（乱入一只小埋狛哥 hhhhhhhhh但是真的太可爱了）<br>
<img src="https://MrContinue.github.io/post-images/1586914060846.jpg" alt="" loading="lazy"><br>
超级甜wwww<br>
<img src="https://MrContinue.github.io/post-images/1586914082819.jpg" alt="" loading="lazy"><br>
我滴电脑锁屏，博客背景QwQ 这个配色！这个画功！啊我我我我！awsl！！！<br>
<img src="https://MrContinue.github.io/post-images/1586914148124.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586914159977.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1586914167899.jpg" alt="" loading="lazy"><br>
啊啊啊啊啊啊啊啊awsl，这个真的又可爱又甜awsl awsl awsl！！！</p>
<hr>
<p>百度贴吧它是个好东西啊！qwq<br>
在里面找到了很多高清的狛哥图呢qwq<br>
<img src="https://MrContinue.github.io/post-images/1587081692441.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587081751601.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587081763634.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587081779835.jpg" alt="" loading="lazy"><br>
哈哈哈哈哈哈这张Q版的真的超级可爱www<br>
<img src="https://MrContinue.github.io/post-images/1587081814565.jpg" alt="" loading="lazy"><br>
好喜欢这种休闲的狛哥啊qwq<br>
<img src="https://MrContinue.github.io/post-images/1587081875886.jpg" alt="" loading="lazy"><br>
Q版的我统统awsl！<br>
<img src="https://MrContinue.github.io/post-images/1587081942925.jpg" alt="" loading="lazy"><br>
awsl<br>
<img src="https://MrContinue.github.io/post-images/1587081959856.jpg" alt="" loading="lazy"><br>
awsl<br>
<img src="https://MrContinue.github.io/post-images/1587081977385.jpg" alt="" loading="lazy"><br>
awsl<br>
<img src="https://MrContinue.github.io/post-images/1587081995161.jpg" alt="" loading="lazy"><br>
awsl<br>
<img src="https://MrContinue.github.io/post-images/1587082037992.jpg" alt="" loading="lazy"><br>
这张自信滴狛哥实在是太可了wwww<br>
<img src="https://MrContinue.github.io/post-images/1587082065580.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587082078626.jpg" alt="" loading="lazy"><br>
多种狛哥，多种快乐qwq</p>
<hr>
<p>事实证明，手机是个好东西。在手机上又搜刮到了好多好多美腻的狛哥qwq<br>
多图预警！<br>
<img src="https://MrContinue.github.io/post-images/1587285162431.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285172588.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285188825.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285203728.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285243010.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285260883.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285272004.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285283819.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285298517.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285320906.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285331010.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285378219.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285389699.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285441711.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285452181.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285461865.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285472149.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285482486.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285492254.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285504483.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285513854.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285526059.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285536274.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285546758.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285556473.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285566363.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285575866.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285592926.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285602570.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285612254.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285624326.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285636603.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285646975.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285656248.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285671277.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285683047.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285693065.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285704190.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285715633.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285724595.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285734305.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285744669.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285753659.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285762341.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285771163.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587285797102.jpg" alt="" loading="lazy"></p>
<hr>
<p>www和好姐妹一起吸狛获得的图QwQ<br>
<img src="https://MrContinue.github.io/post-images/1587521799613.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587521932563.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587522026904.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587522038707.jpg" alt="" loading="lazy"><br>
<img src="https://MrContinue.github.io/post-images/1587522051896.jpg" alt="" loading="lazy"></p>
<hr>
<p>所有滴图都是精选滴，有好看滴图可以私信我哦qwq<br>
要是宁也想把宁滴老公or老婆放上来，欢迎私信我哦，联系方式见首页qwq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-J2019游记]]></title>
        <id>https://MrContinue.github.io/post/csp2019-j-you-ji/</id>
        <link href="https://MrContinue.github.io/post/csp2019-j-you-ji/">
        </link>
        <updated>2020-04-12T07:16:07.000Z</updated>
        <content type="html"><![CDATA[<p>（突然发现之前写的游记被自己删了，应该是连自己都看不下去了，那就重新写一篇咯，即便过去了半年，但是所有的事情记得还是很清楚呢qwq）</p>
<h2 id="初赛">初赛</h2>
<h3 id="初赛前一天-20191018">初赛前一天 2019.10.18</h3>
<p>之前在网上下载了近8年来的初赛例题，课件、晚上都在做。还特意拿了一个小本子出来记录重点知识，背后还收集了一点自己做错的题。那个时候还不知道有洛谷这样可以线上做题的OI网站，白费了很多纸张和时间精力，但是现在想起来效果还是不错的。</p>
<p>初赛时知道自己考上了信竞。初赛前教练也有带把大家聚在一起，然后分发了初赛模拟卷，让大家在电脑上作答，反正不是那种很正规的，就是试试水，了解一下自己能力。</p>
<p>其实说实话吧，之前做的那几套初赛卷子里面一直不太敢记分数，但是有一两套记了分，大概是<strong>40~50分</strong>的样子。我自己个人感觉分数很低，然后上网上查，看到网上说“<strong>70分</strong>左右就能过'”，我：？？？？？，我自闭了。</p>
<p>当天晚上自己测出来的成绩大概是<strong>54分</strong>的样子，这个分数还成了我当时做过的所有初赛及模拟卷子里考得最好的一次。教练就说大概<strong>65分左右</strong>就不用担心。我：？？？？？，然后就更自闭了。</p>
<p>因为当时初入竞赛，学校开了很多竞赛讲座，也灌输了不少竞争激烈的例子。都说是什么“初二怎样怎样……”，又提到“什么什么班又必须怎么怎么样”，所以初赛前一天非常紧张，一直想着“要是我连初赛都过不了，那我不就完了吗。”之类的东西。</p>
<p>所以当天早上太阳穴痛，被强制放松，看会儿电视，下午和晚上敷敷衍衍复习了自己之前做笔记的小本子，又看了两眼之前自己做的初赛卷子。草草入睡，和平常一样失眠。</p>
<h3 id="初赛当天-20191019">初赛当天 2019.10.19</h3>
<p>当天去的时候很紧张，但是也很激动，毕竟这是我OI生涯的第一次正式考试。</p>
<p>去之前听教练说就在三教楼一楼考试，所以地形比较熟悉，没有耽误什么时间，就是找自己在哪个考场花了点时间。因为提前了一会，所以途中还拜访了每个考场里认得到的老师。</p>
<p>找到了自己的考场过后就掏出笔和准考证啊，和平常考试流程差不多。</p>
<p>监考我们的老师曾经教过我一段时间，还是认得到的，一切都是熟悉的事物，所以不是特别紧张了。</p>
<p><strong>开始考试</strong>，大概浏览了一下题型、题量，和之前心里的预估差不多。<br>
考试过程中肯定有很多原题，但是记得很清楚的就是一道填空题，关于二叉树的。因为这道题是我在某机构学习二叉树时的一道开胃题，当时还蒙对了，特高兴。后来在刷以前的初赛题的时候又刷到过，立刻做对了。但是这个时候有点紧张，忘了当初选的是C还是D了，就随便选了个。结果最后成绩出来的时候发现错了，特不甘心。</p>
<p><strong>当然初赛最怕的还是补全程序和看程序写结果</strong>。我心里预估的很准，就是基础的简单一点的分能拿到，稍微难一点的就有点悬。所以有40%的难题是玄学连蒙带猜填的答案。后来发现对的还不少，嗨森qwq。</p>
<p>开始20多分钟就基本上写完了，空了一点怎么也想不出来的题，开始怼着补充程序题猛（发）算（呆）。<br>
到最后觉得无可救药了，就结合上下文蒙了几个答案上去。随便在草稿纸上估了个分，有点忘了，大概估分60-吧，可能就是凉凉了吧。考前教练给我们打过气，说我们以后还有机会，这次没发挥好没事。我想着那也没办法，就只能这样了。</p>
<p><strong>然后，开始发呆。</strong><br>
<strong>发呆发累了，双手枕头准备睡觉。</strong><br>
<strong>睡不着，开始看别人睡觉。。。</strong>（真的，当时我前面的人都开始打鼾了）</p>
<p>……</p>
<p>看了看手表。震惊！还有10分钟了！！<br>
果断爬起来检查自己写的答案。<br>
虽然一般情况下“检查”这个行动一般是无意义行动，但是今天这么重要的考试还是要认真看一看。<br>
选择题个人感觉没有什么事，有什么事情那也没法补救。<br>
最担心的是看程序写结果和补充程序。所以多检查了一会。我检查一般就是随便逮一道想了很久的题然后疯狂检查。</p>
<p><strong>我的这次初赛，是特别神奇的一次，因为在最后发生了奇迹。</strong><br>
下面是本次初赛奇迹发生时我的心理过程：</p>
<pre><code>诶？等等？
这道题好像错了？？
（反复计算）
诶，确实错了诶！我运气真好一看就遇到了错的题。
（长吁一口气）
等等！
（震惊！）
这道题以后的题我好像都是根据这道题的答案推出来的！
妈耶，凉凉。
（看了看手表还剩5分钟）
（发疯修改）
啊……终于……
我可能就只能做到这样了吧……听天由命，我也不知道改对没有，也不知道原来的答案对不对……
（看手表，此时还剩1分半）
（心脏狂跳）
（监考老师背景音：同学们检查自己的名字写好没有哈……）
……
（监考老师背景音：收卷了，不要写了哈）
……

</code></pre>
<p>我最后修改的一批题的分数，足以让我从60分到68+。<br>
但是如果不行的话，扣掉的分数绝对致命。<br>
应该还是有救的吧。我这样想。</p>
<p>……</p>
<p>既然收卷了，就不去管它啦。<br>
初赛的时候还没有在信竞班里结识好朋友，自己收拾东西又很慢，收完背包过后从教室出来，差不多所有人都走完了。好朋友在等我，爱你qwq。<br>
然后去看了一眼老师们，看到了曾经教过我的老师温暖的微笑，<strong>真幸福啊。</strong></p>
<p>和好朋友出来的时候碰见培训机构宣传，宣传的小姐姐惨遭我们等逗比怼。<br>
我们路过的时候，前面的男生还在很皮的边走边说：“你看你这个宣传资料，现在都没有NOIP啦，是CSP，记得改哦。”<br>
小姐姐尴尬一笑，转而向我和我的好朋友推荐她的机构。<br>
她可能以为女生更好说话一点，但是你哥我不是普通女生，爷不是那种羞涩的那种兔兔，你爷就是你爷。<br>
<code>“啊，你们考的怎么样啊？”</code><br>
闺蜜正想说话，我笑道：<br>
<code>“不怎么样，很不怎么样，我都凉了。”</code><br>
很明显，小姐姐并不知道自己迎来的是这样的答案，她愣了一下，很快又露出尴尬而不失礼节的微笑，准备再次开始宣传。<br>
But now，我和我的好朋友已 经 溜 了，给她留下了一个帅气而仓促的背影。（笑）</p>
<h3 id="初赛in-end">初赛in end</h3>
<p>晚上就陆陆续续有初赛答案出来了。当时还不愿意对答案。因为从小到大，我对了答案过后总是有不太好的结果。</p>
<p>就以平常来看，要是对了答案出来结果不错，那么我往往会在一些古怪的地方扣分。比如，忘了某一步啊，书写不标准啊，最后的实际结果往往和预想的有极大差距。我爹曾直言：你自己对答案估出来的分不算数，一般要减上20多分才离实际分数差不多。这不是夸张句，真的是这样。<br>
要是对了答案估出来的分不好，那就是真的不好，往往会先伤心一波，等拿到卷子了再伤心一波。</p>
<p>所以，当时我并没有对答案。<br>
但是！（转折）我还是没有忍住好奇心，看了看我最后5分钟里改那的几道题。</p>
<p>……<br>
……<br>
<strong>wsl我对了！！！！</strong></p>
<p>我：&amp;Grh76TGTu&amp;*(667h%ryg&amp;￥%……7r！！！</p>
<p>真的，就是那种无比酸爽的感觉。就是心里悬着的石头突然猛烈的冲向地面，引发了地（大）震（吼）、海（大）啸（叫）等多种自（疯）然（子）灾（行）害（为）。</p>
<p>当时我就觉得非常、非常开心了。</p>
<p>最后出来的成绩是72分，听教练说68左右就能过。我看了一下，如果我最后没有改那一道题，那我基本上就是卡线过，甚至过不了。But，who care？反正我已经过了。</p>
<p>wslwsl。那天我下楼都是跳着下的，作业写的字都是飘的。</p>
<p><strong>这也算为我的OI之路开了一个好头吧qwq</strong></p>
<hr>
<h2 id="复赛">复赛</h2>
<h3 id="复赛前的很多天-201910xx~20191124">复赛前的很多天 2019.10.xx~2019.11.24</h3>
<p>知道了本次机试我们学校主办，学校还在非常显眼的地方拉了横幅，考试是在熟悉的环境里，非常开心。</p>
<p>在复赛之前自己先干了一些事情。比如水了水往年的T1、T2，学了学贪心（没错我复赛之前还不会贪心，其实现在也不会，浓雾），水了水模拟练习，看了看往年例题题解。</p>
<p>在复赛之前老师把我们拉在一起集训了一周左右吧，周末不休，每天晚自习都去机房，所以我（短暂的）记住了很多很多东西。</p>
<p><strong>其实复赛之前我自己心里就是是很没底气的。刷了以往的NOIP试题过后就更是如此。</strong></p>
<p>但与其说是没底气，只不过是很清楚自己的水平拿不了1=，就和教练说的一样，我现在考NOIP，就是考着玩。经过一些NOIP题目的历练，我一般能比较快的做出T1，有些难的T2就开始犯晕，水题的时候基本上就没考虑过T3、T4。</p>
<p><strong>教练本来给我们的计划是，上去先把T1、T2水了，然后T3、T4骗点分，1=轻松到手。</strong></p>
<p>但是当时我还是一个递推递归都不会的伪OIer，但是教练在我们临时集训的短短几天，不到一周的时间里，就教给了我们<strong>递归、递推、贪心、DFS、BFS以及搜索很多的例题讲解</strong>。这真的是一个很高的效率，但是我总感觉我无法像教练规划的那样顺利获得1=。因为集训的进度拉得很快，所以当初我的DFS代码是修改了很久才对的，BFS代码还是直接copy的教练PPT里的代码。递归递推以前在机构里学习过，所以问题就不大。至于贪心，我现在都没有怎么搞懂。</p>
<p>所以我的心里大概知道<strong>自己的水平差不多就是2=里的中下等水平。我自己估摸着，自己在考场上应该是T1秒，T2得大部分分，T3得小部分分，T4根本碰不了</strong>。</p>
<p><strong>最后的成绩证明，我自己还是很清楚自己真实实力的。</strong></p>
<h3 id="复赛前一天-20191125">复赛前一天 2019.11.25</h3>
<p>复赛前一天，下午体训。去操场的途中路过机房（其实并不顺路，只是专门为了去看看机房的布置），突然被教练喊住，并让我在某个机房等他。<br>
在这个机房里，许多身着陌生校服的人正在调试机子。讲台上有我们信竞班里的同班同学，大家尴尬的站在一起。</p>
<p>因为我们就是本学校的人，所以对调机子这件事情比较佛系。只是我比较担心一件事情。我平常竞赛课坐的位置上键盘的Backspace键有点容易被卡在键盘里，有的时候它会趁你不注意就删你一大段程序，并且把这个被键盘卡住的玩意儿搞出来还是需要一点时间。我有点担心那个键盘的问题。</p>
<p>不一会儿教练来了，递给了我们每人一张纸，上面印着考试的基本注意事项。这个反正明天也要发的，所以并没有什么问题。</p>
<p>教练特别强调，这次的机试所有的cpp文件就直接放在C盘里，不要单独建文件夹。随后又叫我们去通知其他人。</p>
<p>憨憨的我先跑到体训集合地向老师请了一会假，去教学楼的路上又遇见几个同学，随口问了问就跑了三楼，累的像条狗，最后通知到位了。体训那边也差不多进行了20多分钟了。</p>
<p>总之对明天是很期待的，听说比赛不仅有矿泉水，还有小面包吃。</p>
<p>复赛前一天，日常失眠。</p>
<h3 id="复赛当天-20191126">复赛当天 2019.11.26</h3>
<p>到达学校的时候已经是卡点进了，门口本来还有人在发什么本子，管也没管就飞冲进去了。</p>
<p>结果到达考场那里的时候大家都堆在门口，门口有铁栏杆和保安拦着，大家就争相去看自己的考号和考场。<br>
因为当时附近有很多认得到的的同学，所以没费什么劲儿就知道了自己的考号和考场。我是在3考场的。<br>
挺紧张的，认得到的同学们就开始聊天。记得最深的是当时有lmpy大佬，我一出楼梯口他就看见我了，并大声的叫住了我，简单的告诉了我相关的情况，后来看到考场过后他也一直在和我们聊天，多亏了他，我的紧张也好了一点点。<br>
当时大家就开始讨论教练去哪里了，我们觉得他一定是去避嫌了，并且大家一致约定要是看到教练了，千万不要叫他，不然难免让人产生误解。后来证明，我们的约定是很有必要的。</p>
<p>途中的趣闻就是门口的一个矮矮胖胖的小朋友指着身边比他更矮的瘦瘦小朋友大声说：“大家看这里有个五年级的小学生！”我们就笑着问他，你也不还是小学生吗？结果他尴尬的回答：“我也是啊，但是我是小学六年级的诶！”让我想起了我的六年级，虽然也是不久之前，却感觉像过去了很久。最重要的，大概就是从儿童慢慢步入少年的过程吧。</p>
<p>过了大概10分钟左右吧，门开了，大家就争相跑到自己考场门口，把自己的包放在门口。不知道其他考场是不是一样，在蜂拥而入，本考场的老师并不及时的拦住了部分人群，其中就包括动作极慢的我。简单观察了一下，除了每个座位之间有薄薄的泡沫隔板以外，其他和平常没有什么不同。这个考场是某次教练出差时大家聚在一起打游戏的地方。回想起来那真是一个<strong>刺激</strong>的夜晚啊（车车，好快的车车！[大雾]）</p>
<p>说来巧合，这次复赛监考我的，就是初赛的那个曾经教过我的老师。实话实说，当时他教我的时候，我对他是比较不满的，可能是因为他的脾气有点不太好，也有可能是因为我太喜欢上一个老师。毕竟，当你的老师从高高帅帅脾气好变成了高高胖胖脾气差，十个人应该有七个人都会不太适应吧？当初我在他的班上就是属于做的题多（很明显，那些题有部分是抄的），会的东西多（只是比一部分人多一点），但是特别傲娇，特别高冷的那种（事实上我不是这种人，相信你从我的文笔里也看出来了）。所以当时留给他的印象应该是比较深的。</p>
<p>但是很快我就找到了我的位置，是老师告诉我的，他还是有暗中帮助我的。我坐的位置是一列的最前面，要更衣啊，要观察门口情况啊，都比较方便。</p>
<p>当时在猛烈争执的是我旁边的座位。开始是一个瘦的能见到骨头的男生坐在上面，后来又有一个高高的男生过来争执，说这是他的座位。我承认，后来的这个男生长的挺好看的（花痴羞耻），虽然争执的时候我也插不上嘴，但是暗地里还是想后来的男生坐过来。<br>
最终，我的身边坐的是那个好看的小哥哥（花痴脸红）。当然不是因为他长得好看，是因为之前的男生看错考号了。</p>
<p>开始考试之前检查C盘的状态，记得教练说过要是你自己看完了，你就找监考老师，装憨，让他帮你看看调对了没有，这样比较保险。所以我就憨憨的叫了老师过来看，老师检查了一下是对的就走了。<br>
这个时候旁边的小哥哥一头忙碌，他是真的没搞懂。于是我在线指导了一下，老师也过来看了一下，最后还是搞对了，小哥哥非常有礼貌的回了一句“谢谢”。啊怎么长的好看的人声音也这么好听啊www（花痴脸红），偷偷看了眼，他不是我们中学的，貌似姓刘，但是准考证一眼就晃过去了，也不知道到底别人是不是姓刘。</p>
<p><strong>然后开始考试。</strong></p>
<p>T1，看到我就笑了，string秒的，所有样例过了。</p>
<p>T2，比较清楚怎么做的，大概就是一个结构体数组，开始的时候觉得很简单，就随便敲的，但是后来发现样例一直过不了，就搁那儿一直调，最后两个小样例过了，大样例炸了。</p>
<p>T3，很认真的花了时间手撸样例，打了一堆工整的草稿（平常我的草稿绝对狂野风，但是今天心情比较平静，又有喜欢的太阳，又很舒适的理清了思路，旁边还有好看的小哥哥，酥服），理清了题目，大概明白就是像股市一样的操作，但是不太会写，就只骗了T=1的分。</p>
<p>T4，读了下题，觉得应该是图或者树之类的操作，还没学就没管了。<br>
剩下的时间都在调T2和发呆。</p>
<p>中途发了矿泉水，莫得小面包（生气状）。那瓶没喝完回去被当做珍宝一样怎么都舍不得喝，空瓶子也舍不得扔。最后它在其他矿泉水的混淆视听中被丢掉了。</p>
<p>整T2的时候教练进了我们考场和监考老师问了几句，顺便看了几眼。我坐在离门最近的位置，看到他刚想条件反射的叫一声，结果马上回忆起来大家在考场门前的约定，并且教练用眼神也示意我千万不要叫他。于是乎我到嘴边的“d老师！”就变成了口水被我吞进了肚子里。<br>
现在想起来可真是惊险啊，真的就差一点点吼出来。。。</p>
<p>考试过程中最担心的就是freopen写对没有，特别害怕把r和w写反导致抱灵。检查了很多遍，最后还是没有错。考试最后10分钟的时候去了freopen的注释，反复保存cpp文件。</p>
<p>最后交卷的时候已经比较不耐烦了，因为根本做不出来了。很轻松的离开了座位，去拿自己的背包。那天的草稿纸、被揉的都要烂掉的比赛注意事项、准考证，现在都静静地压在我的桌子底下。</p>
<p>怎么说呢，就和自己预估的差不多吧。</p>
<h3 id="复赛in-end">复赛in end</h3>
<p>复赛结束出来，爹来接我，我就如是说考得一般，也就那样。<br>
当时其实是比较悲观的，以为自己连3=都没有，事实上，T1过了的都有奖。</p>
<p>最后的分出来，2=，140=100+10+30+0。玄学，玄学。<br>
大家大部分也没有1=，基本都是2=。但有一位大佬以250的美妙分数得到了1=，真是tql！%%%%</p>
<hr>
<p>开始以为NOIP死了，没想到成为绝版的竟然是CSP。这段记忆我已经好好珍藏了。</p>
<p>OI魔芋，奥利给！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1562 丑数]]></title>
        <id>https://MrContinue.github.io/post/bsoj1562-chou-shu/</id>
        <link href="https://MrContinue.github.io/post/bsoj1562-chou-shu/">
        </link>
        <updated>2020-04-11T10:17:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description"><strong>Description</strong></h2>
<pre><code>丑数是指素因子都在集合{2,3,5,7}内的整数，第一个丑数是1。
现在输入n(n&lt;=4000)，输出第n个丑数。
</code></pre>
<h2 id="input"><strong>Input</strong></h2>
<pre><code>输入文件仅一行为一个整数n。
</code></pre>
<h2 id="output"><strong>Output</strong></h2>
<pre><code>输出文件仅一行为一个整数，表示第n个丑数。
</code></pre>
<h2 id="sample-input"><strong>Sample Input</strong></h2>
<pre><code>5
</code></pre>
<h2 id="sample-output"><strong>Sample Output</strong></h2>
<pre><code>5
</code></pre>
<hr>
<h3 id="这道题窝先打的stl优先队列-然后全wa"><strong>这道题窝先打的STL优先队列 然后全WA。。。。</strong></h3>
<p>看了前辈的<strong>打表程序</strong> 对拍了一下 发现很有问题（废话</p>
<p>后来发现问题出在 <strong>丑数集合中不能有重复数字</strong></p>
<p>即 <strong>一个相同的数可能被视作多个数</strong></p>
<p>于是乎就短暂的考虑了<strong>桶</strong>。。。。</p>
<p>当开始试验的时候憨憨癌发作 以为数组只用开4000就OK</p>
<p>后来发现事情没那么简单。。。。。</p>
<p><strong>这个桶应该开到第4000个丑数的值那么大</strong></p>
<p>前辈的打表程序发现是<strong>2亿多</strong>。。。。。。</p>
<p><strong><s>（MLE的芳香！</s></strong></p>
<p>于是飞快放弃了。。。。</p>
<p>最后选用的是<strong>C++自带的超强的set函数</strong></p>
<p>先上网自学了一波 知道了<strong>set函数具有去重+排序的美妙功能</strong></p>
<p><strong>非常符合这道题的要求啊！</strong></p>
<p>于是自学set过后A了这道水题。。。。。。</p>
<p><strong>果然还是窝太菜了QAQ</strong></p>
<h3 id="set效率很高的-不愧是c">set效率很高的 不愧是C++</h3>
<p><a href="https://www.cnblogs.com/caiyishuai/p/8646345.html">自学set的文章网址</a></p>
<p>然后就是<strong>0ms</strong>AC代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt; 

#define maxn 1005
using namespace std;

set &lt;int&gt; a; 

int main()
{
	a.insert(1);
    //先插入堆顶操作元素
	int n;
	cin&gt;&gt;n;
	for(int i=2;i&lt;=n;i++)
    //因为初始化堆顶视为一次操作 所以从i=2开始
	{
		int num=*a.begin();
        //先定义一个变量储存当前堆顶
        //其实和指针没关系的。。。。
		a.insert(num*2);
        //分别插入操作数 set会自行排序维护根堆
		a.insert(num*3);
		a.insert(num*5);
		a.insert(num*7);
		a.erase(a.begin());
        //再将堆顶弹出
	}
	cout&lt;&lt;*a.begin()&lt;&lt;endl;
    //最后的堆顶就是答案啦~~~
	return 0;
}
</code></pre>
<p>有什么疑问可以问窝 但是窝很菜的。。。</p>
<p><s>CSP普及才Au宁敢问吗</s></p>
<hr>
<h3 id="2020年2月9日1019更新">2020年2月9日10:19更新</h3>
<p>在听了did讲课过后 窝知道了<strong>这道题其实可以不用set 而且没必要</strong></p>
<p><s>毕竟这就是一道堆练习嘛</s></p>
<p>窝再梳理了一下我的心路历程 发现实际上窝离正<s>常</s>确方法就差那么一丢丢</p>
<p>这道题的确要考虑到<strong>去重</strong></p>
<p>但没有必要用set去重 因为正如did所说的一样：</p>
<pre><code>“宁现在用了set，以后不能用set的时候宁怎么办？”
</code></pre>
<p>所以<strong>可以直接在堆的代码里加入少量的<s>盐</s>去重算法以达到同样效果</strong></p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

#define maxn 1005
using namespace std;

priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; a;
//定义一个小根堆
//这里使用的食材（bushi）工具是STL
//各位大佬可以自己手写堆 勿喷蒟蒻

int main()
{
	a.push(1);
	int n;
	cin&gt;&gt;n;
	for(int i=2;i&lt;=n;i++)
	{ 
		int num=a.top();
        //拿出堆顶元素 即操作数
		a.push(num*2);a.push(num*3);
        //放入其他丑数
		a.push(num*5);a.push(num*7);
		while(a.top()==num) a.pop();
        //去重 只要相同就pop
	}
	cout&lt;&lt;a.top()&lt;&lt;endl;
    //最后的堆顶就是第n个丑数啦~~~
	return 0;
}
</code></pre>
<h2 id="提交过后性能分析">提交过后性能分析</h2>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:right">Time</th>
<th style="text-align:right">Memory</th>
<th style="text-align:right">Length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">堆</td>
<td style="text-align:right">0ms</td>
<td style="text-align:right">1863KB</td>
<td style="text-align:right">0.39KB</td>
</tr>
<tr>
<td style="text-align:right">set</td>
<td style="text-align:right">0ms</td>
<td style="text-align:right">1997KB</td>
<td style="text-align:right">0.34KB</td>
</tr>
</tbody>
</table>
<p><strong>综上分析 堆更优</strong></p>
<p>堆的好处：易懂 易想 耗时较少</p>
<p>set的好处：好写 方便 码量较少</p>
<hr>
<h2 id="求点赞qaq不容易啊">求点赞QAQ不容易啊</h2>
<pre><code>常见疑问一：
OI上可以用set吗？
回答：
应该可以 但我没用过（
常见疑问二：
你BB太多 可以举报吗？
回答：
QAQ！！！不看就行啦！！！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1495 拾垃圾的机器人3541]]></title>
        <id>https://MrContinue.github.io/post/bsoj1495-shi-la-ji-de-ji-qi-ren-3541/</id>
        <link href="https://MrContinue.github.io/post/bsoj1495-shi-la-ji-de-ji-qi-ren-3541/">
        </link>
        <updated>2020-04-11T10:16:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<pre><code>有一块地被划分成了n*m个区域，在一些区域里有垃圾要拾捡。
现在科研人员开发了一个能捡垃圾的机器人，机器人每一次都可以移动一个区域的距离。
假设机器人从最左上区域出发，他每次只能向右或者向下走。
每次他到达一个点，就会自动把这个点内的垃圾拾掉。
问：该机器人最多能够拾多少垃圾？
在最多情况下，有多少种方案？
</code></pre>
<h2 id="input">Input</h2>
<pre><code>输入文件的第一行为两个整数n和m；
接下来有一个n*m的01矩阵。
矩阵中的第i行j列的数字a[i][j]=0表示为空地。
a[i][j]=1表示为垃圾。
</code></pre>
<h2 id="output">Output</h2>
<pre><code>输出两行，第一行为一个数字表示最多拾到的垃圾，第二行为一个数字表示在最多情况下，有多少种方案。
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>3 3
100
000
010
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>2
3
</code></pre>
<h3 id="今天也是菜得水3级题的一天呢"><s>今天也是菜得水3级题的一天呢</s></h3>
<p>因为机器人只能向下和向右走，满足无后效性。</p>
<p>所以我们考虑用DP作答。</p>
<p>首先，从<strong>输入上</strong>就有那么一个小小的坑<s>就只有我觉得是坑吧</s>，请大家研究一下矩阵的输入。</p>
<p><strong>科科，是没有空格的。</strong></p>
<p>所以我们要用string或者char数组来读入~</p>
<p>接着分析题意。</p>
<p>对于题目中的<s>人工智障</s>机器人，<strong>它到一个点的路径只有两<br>
种：从上来或者从左来。</strong></p>
<p>也就是说，对于题目中的<strong>点a[i][j]</strong>，它只可能源于<strong>点a[i-1][j]<strong>与</strong>点a[i][j-1]</strong>。</p>
<p>这点理清了，下面就可以顺理成章地理解了。</p>
<h2 id="一求最多捡到的垃圾">一：求最多捡到的垃圾</h2>
<p>我们可以用f[i][j]来统计<strong>捡到的最多垃圾数</strong>。由<strong>加法原理</strong>得出，<strong>f[i][j]=f[i-1][j]+f[i][j-1]</strong>。</p>
<p>实现代码：</p>
<pre><code class="language-cpp">//DP求最多拾到的垃圾 
for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
</code></pre>
<p>这样下来，f[n][m]就是到达终点时捡到的最多垃圾数。即我们要的答案。</p>
<h2 id="二求在最多情况下有多少种方案">二：求在最多情况下，有多少种方案？</h2>
<p>我们可以用q[i][j]来统计f最大时的方案数。</p>
<p>可得**有q[i][j]=q[i-1][j]<em>C1+q[i][j-1]<em>C2。</em></em></p>
<p>其中，<strong>若f[i-1][j]+a[i][j]==f[i][j]，则C1=1，反之为0</strong>；</p>
<p><strong>若f[i][j-1]+a[i][j]==f[i][j]，则C2=1，反之为0；</strong></p>
<p>但是这样做还有一个问题：<strong>边界值的问题。</strong></p>
<p>对于矩阵来说，最上和最右的点，是一定可以到达的。<strong>所以，我们可以把它们的初值赋为1。</strong></p>
<p>这样一来，我们的计算式子不仅有了初始值，还没有了越界的漏洞。</p>
<p>实现代码：</p>
<pre><code class="language-cpp">//DP求路径数 
for(int i=1;i&lt;=n;i++)
{
	q[1][i]=1;
	q[i][1]=1;		
}
//边界赋初值 
for(int i=2;i&lt;=n;i++)
	for(int j=2;j&lt;=m;j++)
	{
		long long C1,C2;
		if(f[i-1][j]+a[i][j]==f[i][j])
			C1=1;
		else C1=0;
		if(f[i][j-1]+a[i][j]==f[i][j])
			C2=1;
		else C2=0;
		q[i][j]+=q[i-1][j]*C1+q[i][j-1]*C2;
	}
</code></pre>
<hr>
<p><em><strong>似乎</strong></em> 一切都功德圆满了。</p>
<p>等等，你有看到窝的加粗嘛？</p>
<p>当初<s>自信的</s>可怜的continue就是这样WA的。。。。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/sqy2tbip.png" alt="" loading="lazy"></figure>
<p>在<strong>一群乐于助蒻的大佬</strong>指导下，窝当时整个人就一懵的。</p>
<h2 id="没错本题最重要的部分不在前面">没错，本题最重要的部分不在前面。</h2>
<h1 id="其实最重要的是">其实，最重要的是</h1>
<h1 id="开-long-long">开 long long 。 。 。 。 。</h1>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/hgpfg590.png" alt="" loading="lazy"></figure>
<p>惊不惊喜？</p>
<p>完整代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

#define maxn 105
using namespace std;

string s[maxn];
long long a[maxn][maxn]; //a数组表示矩阵 
long long f[maxn][maxn]; //f数组表示当前捡的最多垃圾数 
long long q[maxn][maxn]; //g数组表示f最大时的方案数 

int main()
{
	long long n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;s[i];
		for(int j=1;j&lt;=m;j++)
			a[i][j]=s[i][j-1]-'0';	
	}

	//DP求最多拾到的垃圾 
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
	cout&lt;&lt;f[n][m]&lt;&lt;endl;
	
	//DP求路径数 
	for(int i=1;i&lt;=n;i++)
	{
		q[1][i]=1;
		q[i][1]=1;		
	}
	//边界赋初值 
	for(int i=2;i&lt;=n;i++)
		for(int j=2;j&lt;=m;j++)
		{
			long long C1,C2;
			if(f[i-1][j]+a[i][j]==f[i][j])
				C1=1;
			else C1=0;
			if(f[i][j-1]+a[i][j]==f[i][j])
				C2=1;
			else C2=0;
			q[i][j]+=q[i-1][j]*C1+q[i][j-1]*C2;
		}
	cout&lt;&lt;q[n][m]&lt;&lt;endl;
	return 0;
}

</code></pre>
<hr>
<p><strong>QAQ求点赞</strong></p>
]]></content>
    </entry>
</feed>