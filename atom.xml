<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MrContinue.github.io</id>
    <title>Continue的博客</title>
    <updated>2020-04-14T11:28:03.099Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MrContinue.github.io"/>
    <link rel="self" href="https://MrContinue.github.io/atom.xml"/>
    <subtitle>请你照亮我前进的路</subtitle>
    <logo>https://MrContinue.github.io/images/avatar.png</logo>
    <icon>https://MrContinue.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Continue的博客</rights>
    <entry>
        <title type="html"><![CDATA[CSP-J2019游记]]></title>
        <id>https://MrContinue.github.io/post/csp2019-j-you-ji/</id>
        <link href="https://MrContinue.github.io/post/csp2019-j-you-ji/">
        </link>
        <updated>2020-04-12T07:16:07.000Z</updated>
        <content type="html"><![CDATA[<p>（突然发现之前写的游记被自己删了，应该是连自己都看不下去了，那就重新写一篇咯，即便过去了半年，但是所有的事情记得还是很清楚呢qwq）</p>
<h2 id="初赛">初赛</h2>
<h3 id="初赛前一天-20191018">初赛前一天 2019.10.18</h3>
<p>之前在网上下载了近8年来的初赛例题，课件、晚上都在做。还特意拿了一个小本子出来记录重点知识，背后还收集了一点自己做错的题。那个时候还不知道有洛谷这样可以线上做题的OI网站，白费了很多纸张和时间精力，但是现在想起来效果还是不错的。</p>
<p>初赛时知道自己考上了信竞。初赛前教练也有带把大家聚在一起，然后分发了初赛模拟卷，让大家在电脑上作答，反正不是那种很正规的，就是试试水，了解一下自己能力。</p>
<p>其实说实话吧，之前做的那几套初赛卷子里面一直不太敢记分数，但是有一两套记了分，大概是<strong>40~50分</strong>的样子。我自己个人感觉分数很低，然后上网上查，看到网上说“<strong>70分</strong>左右就能过'”，我：？？？？？，我自闭了。</p>
<p>当天晚上自己测出来的成绩大概是<strong>54分</strong>的样子，这个分数还成了我当时做过的所有初赛及模拟卷子里考得最好的一次。教练就说大概<strong>65分左右</strong>就不用担心。我：？？？？？，然后就更自闭了。</p>
<p>因为当时初入竞赛，学校开了很多竞赛讲座，也灌输了不少竞争激烈的例子。都说是什么“初二怎样怎样……”，又提到“什么什么班又必须怎么怎么样”，所以初赛前一天非常紧张，一直想着“要是我连初赛都过不了，那我不就完了吗。”之类的东西。</p>
<p>所以当天早上太阳穴痛，被强制放松，看会儿电视，下午和晚上敷敷衍衍复习了自己之前做笔记的小本子，又看了两眼之前自己做的初赛卷子。草草入睡，和平常一样失眠。</p>
<h3 id="初赛当天-20191019">初赛当天 2019.10.19</h3>
<p>当天去的时候很紧张，但是也很激动，毕竟这是我OI生涯的第一次正式考试。</p>
<p>去之前听教练说就在三教楼一楼考试，所以地形比较熟悉，没有耽误什么时间，就是找自己在哪个考场花了点时间。因为提前了一会，所以途中还拜访了每个考场里认得到的老师。</p>
<p>找到了自己的考场过后就掏出笔和准考证啊，和平常考试流程差不多。</p>
<p>监考我们的老师曾经教过我一段时间，还是认得到的，一切都是熟悉的事物，所以不是特别紧张了。</p>
<p><strong>开始考试</strong>，大概浏览了一下题型、题量，和之前心里的预估差不多。<br>
考试过程中肯定有很多原题，但是记得很清楚的就是一道填空题，关于二叉树的。因为这道题是我在某机构学习二叉树时的一道开胃题，当时还蒙对了，特高兴。后来在刷以前的初赛题的时候又刷到过，立刻做对了。但是这个时候有点紧张，忘了当初选的是C还是D了，就随便选了个。结果最后成绩出来的时候发现错了，特不甘心。</p>
<p><strong>当然初赛最怕的还是补全程序和看程序写结果</strong>。我心里预估的很准，就是基础的简单一点的分能拿到，稍微难一点的就有点悬。所以有40%的难题是玄学连蒙带猜填的答案。后来发现对的还不少，嗨森qwq。</p>
<p>开始20多分钟就基本上写完了，空了一点怎么也想不出来的题，开始怼着补充程序题猛（发）算（呆）。<br>
到最后觉得无可救药了，就结合上下文蒙了几个答案上去。随便在草稿纸上估了个分，有点忘了，大概估分60-吧，可能就是凉凉了吧。考前教练给我们打过气，说我们以后还有机会，这次没发挥好没事。我想着那也没办法，就只能这样了。</p>
<p><strong>然后，开始发呆。</strong><br>
<strong>发呆发累了，双手枕头准备睡觉。</strong><br>
<strong>睡不着，开始看别人睡觉。。。</strong>（真的，当时我前面的人都开始打鼾了）</p>
<p>……</p>
<p>看了看手表。震惊！还有10分钟了！！<br>
果断爬起来检查自己写的答案。<br>
虽然一般情况下“检查”这个行动一般是无意义行动，但是今天这么重要的考试还是要认真看一看。<br>
选择题个人感觉没有什么事，有什么事情那也没法补救。<br>
最担心的是看程序写结果和补充程序。所以多检查了一会。我检查一般就是随便逮一道想了很久的题然后疯狂检查。</p>
<p><strong>我的这次初赛，是特别神奇的一次，因为在最后发生了奇迹。</strong><br>
下面是本次初赛奇迹发生时我的心理过程：</p>
<pre><code>诶？等等？
这道题好像错了？？
（反复计算）
诶，确实错了诶！我运气真好一看就遇到了错的题。
（长吁一口气）
等等！
（震惊！）
这道题以后的题我好像都是根据这道题的答案推出来的！
妈耶，凉凉。
（看了看手表还剩5分钟）
（发疯修改）
啊……终于……
我可能就只能做到这样了吧……听天由命，我也不知道改对没有，也不知道原来的答案对不对……
（看手表，此时还剩1分半）
（心脏狂跳）
（监考老师背景音：同学们检查自己的名字写好没有哈……）
……
（监考老师背景音：收卷了，不要写了哈）
……

</code></pre>
<p>我最后修改的一批题的分数，足以让我从60分到68+。<br>
但是如果不行的话，扣掉的分数绝对致命。<br>
应该还是有救的吧。我这样想。</p>
<p>……</p>
<p>既然收卷了，就不去管它啦。<br>
初赛的时候还没有在信竞班里结识好朋友，自己收拾东西又很慢，收完背包过后从教室出来，差不多所有人都走完了。好朋友在等我，爱你qwq。<br>
然后去看了一眼老师们，看到了曾经教过我的老师温暖的微笑，<strong>真幸福啊。</strong></p>
<p>和好朋友出来的时候碰见培训机构宣传，宣传的小姐姐惨遭我们等逗比怼。<br>
我们路过的时候，前面的男生还在很皮的边走边说：“你看你这个宣传资料，现在都没有NOIP啦，是CSP，记得改哦。”<br>
小姐姐尴尬一笑，转而向我和我的好朋友推荐她的机构。<br>
她可能以为女生更好说话一点，但是你哥我不是普通女生，爷不是那种羞涩的那种兔兔，你爷就是你爷。<br>
<code>“啊，你们考的怎么样啊？”</code><br>
闺蜜正想说话，我笑道：<br>
<code>“不怎么样，很不怎么样，我都凉了。”</code><br>
很明显，小姐姐并不知道自己迎来的是这样的答案，她愣了一下，很快又露出尴尬而不失礼节的微笑，准备再次开始宣传。<br>
But now，我和我的好朋友已 经 溜 了，给她留下了一个帅气而仓促的背影。（笑）</p>
<h3 id="初赛in-end">初赛in end</h3>
<p>晚上就陆陆续续有初赛答案出来了。当时还不愿意对答案。因为从小到大，我对了答案过后总是有不太好的结果。</p>
<p>就以平常来看，要是对了答案出来结果不错，那么我往往会在一些古怪的地方扣分。比如，忘了某一步啊，书写不标准啊，最后的实际结果往往和预想的有极大差距。我爹曾直言：你自己对答案估出来的分不算数，一般要减上20多分才离实际分数差不多。这不是夸张句，真的是这样。<br>
要是对了答案估出来的分不好，那就是真的不好，往往会先伤心一波，等拿到卷子了再伤心一波。</p>
<p>所以，当时我并没有对答案。<br>
但是！（转折）我还是没有忍住好奇心，看了看我最后5分钟里改那的几道题。</p>
<p>……<br>
……<br>
<strong>wsl我对了！！！！</strong></p>
<p>我：&amp;Grh76TGTu&amp;*(667h%ryg&amp;￥%……7r！！！</p>
<p>真的，就是那种无比酸爽的感觉。就是心里悬着的石头突然猛烈的冲向地面，引发了地（大）震（吼）、海（大）啸（叫）等多种自（疯）然（子）灾（行）害（为）。</p>
<p>当时我就觉得非常、非常开心了。</p>
<p>最后出来的成绩是72分，听教练说68左右就能过。我看了一下，如果我最后没有改那一道题，那我基本上就是卡线过，甚至过不了。But，who care？反正我已经过了。</p>
<p>wslwsl。那天我下楼都是跳着下的，作业写的字都是飘的。</p>
<p><strong>这也算为我的OI之路开了一个好头吧qwq</strong></p>
<hr>
<h2 id="复赛">复赛</h2>
<h3 id="复赛前的很多天-201910xx~20191124">复赛前的很多天 2019.10.xx~2019.11.24</h3>
<p>知道了本次机试我们学校主办，学校还在非常显眼的地方拉了横幅，考试是在熟悉的环境里，非常开心。</p>
<p>在复赛之前自己先干了一些事情。比如水了水往年的T1、T2，学了学贪心（没错我复赛之前还不会贪心，其实现在也不会，浓雾），水了水模拟练习，看了看往年例题题解。</p>
<p>在复赛之前老师把我们拉在一起集训了一周左右吧，周末不休，每天晚自习都去机房，所以我（短暂的）记住了很多很多东西。</p>
<p><strong>其实复赛之前我自己心里就是是很没底气的。刷了以往的NOIP试题过后就更是如此。</strong></p>
<p>但与其说是没底气，只不过是很清楚自己的水平拿不了1=，就和教练说的一样，我现在考NOIP，就是考着玩。经过一些NOIP题目的历练，我一般能比较快的做出T1，有些难的T2就开始犯晕，水题的时候基本上就没考虑过T3、T4。</p>
<p><strong>教练本来给我们的计划是，上去先把T1、T2水了，然后T3、T4骗点分，1=轻松到手。</strong></p>
<p>但是当时我还是一个递推递归都不会的伪OIer，但是教练在我们临时集训的短短几天，不到一周的时间里，就教给了我们<strong>递归、递推、贪心、DFS、BFS以及搜索很多的例题讲解</strong>。这真的是一个很高的效率，但是我总感觉我无法像教练规划的那样顺利获得1=。因为集训的进度拉得很快，所以当初我的DFS代码是修改了很久才对的，BFS代码还是直接copy的教练PPT里的代码。递归递推以前在机构里学习过，所以问题就不大。至于贪心，我现在都没有怎么搞懂。</p>
<p>所以我的心里大概知道<strong>自己的水平差不多就是2=里的中下等水平。我自己估摸着，自己在考场上应该是T1秒，T2得大部分分，T3得小部分分，T4根本碰不了</strong>。</p>
<p><strong>最后的成绩证明，我自己还是很清楚自己真实实力的。</strong></p>
<h3 id="复赛前一天-20191125">复赛前一天 2019.11.25</h3>
<p>复赛前一天，下午体训。去操场的途中路过机房（其实并不顺路，只是专门为了去看看机房的布置），突然被教练喊住，并让我在某个机房等他。<br>
在这个机房里，许多身着陌生校服的人正在调试机子。讲台上有我们信竞班里的同班同学，大家尴尬的站在一起。</p>
<p>因为我们就是本学校的人，所以对调机子这件事情比较佛系。只是我比较担心一件事情。我平常竞赛课坐的位置上键盘的Backspace键有点容易被卡在键盘里，有的时候它会趁你不注意就删你一大段程序，并且把这个被键盘卡住的玩意儿搞出来还是需要一点时间。我有点担心那个键盘的问题。</p>
<p>不一会儿教练来了，递给了我们每人一张纸，上面印着考试的基本注意事项。这个反正明天也要发的，所以并没有什么问题。</p>
<p>教练特别强调，这次的机试所有的cpp文件就直接放在C盘里，不要单独建文件夹。随后又叫我们去通知其他人。</p>
<p>憨憨的我先跑到体训集合地向老师请了一会假，去教学楼的路上又遇见几个同学，随口问了问就跑了三楼，累的像条狗，最后通知到位了。体训那边也差不多进行了20多分钟了。</p>
<p>总之对明天是很期待的，听说比赛不仅有矿泉水，还有小面包吃。</p>
<p>复赛前一天，日常失眠。</p>
<h3 id="复赛当天-20191126">复赛当天 2019.11.26</h3>
<p>到达学校的时候已经是卡点进了，门口本来还有人在发什么本子，管也没管就飞冲进去了。</p>
<p>结果到达考场那里的时候大家都堆在门口，门口有铁栏杆和保安拦着，大家就争相去看自己的考号和考场。<br>
因为当时附近有很多认得到的的同学，所以没费什么劲儿就知道了自己的考号和考场。我是在3考场的。<br>
挺紧张的，认得到的同学们就开始聊天。记得最深的是当时有lmpy大佬，我一出楼梯口他就看见我了，并大声的叫住了我，简单的告诉了我相关的情况，后来看到考场过后他也一直在和我们聊天，多亏了他，我的紧张也好了一点点。<br>
当时大家就开始讨论教练去哪里了，我们觉得他一定是去避嫌了，并且大家一致约定要是看到教练了，千万不要叫他，不然难免让人产生误解。后来证明，我们的约定是很有必要的。</p>
<p>途中的趣闻就是门口的一个矮矮胖胖的小朋友指着身边比他更矮的瘦瘦小朋友大声说：“大家看这里有个五年级的小学生！”我们就笑着问他，你也不还是小学生吗？结果他尴尬的回答：“我也是啊，但是我是小学六年级的诶！”让我想起了我的六年级，虽然也是不久之前，却感觉像过去了很久。最重要的，大概就是从儿童慢慢步入少年的过程吧。</p>
<p>过了大概10分钟左右吧，门开了，大家就争相跑到自己考场门口，把自己的包放在门口。不知道其他考场是不是一样，在蜂拥而入，本考场的老师并不及时的拦住了部分人群，其中就包括动作极慢的我。简单观察了一下，除了每个座位之间有薄薄的泡沫隔板以外，其他和平常没有什么不同。这个考场是某次教练出差时大家聚在一起打游戏的地方。回想起来那真是一个<strong>刺激</strong>的夜晚啊（车车，好快的车车！[大雾]）</p>
<p>说来巧合，这次复赛监考我的，就是初赛的那个曾经教过我的老师。实话实说，当时他教我的时候，我对他是比较不满的，可能是因为他的脾气有点不太好，也有可能是因为我太喜欢上一个老师。毕竟，当你的老师从高高帅帅脾气好变成了高高胖胖脾气差，十个人应该有七个人都会不太适应吧？当初我在他的班上就是属于做的题多（很明显，那些题有部分是抄的），会的东西多（只是比一部分人多一点），但是特别傲娇，特别高冷的那种（事实上我不是这种人，相信你从我的文笔里也看出来了）。所以当时留给他的印象应该是比较深的。</p>
<p>但是很快我就找到了我的位置，是老师告诉我的，他还是有暗中帮助我的。我坐的位置是一列的最前面，要更衣啊，要观察门口情况啊，都比较方便。</p>
<p>当时在猛烈争执的是我旁边的座位。开始是一个瘦的能见到骨头的男生坐在上面，后来又有一个高高的男生过来争执，说这是他的座位。我承认，后来的这个男生长的挺好看的（花痴羞耻），虽然争执的时候我也插不上嘴，但是暗地里还是想后来的男生坐过来。<br>
最终，我的身边坐的是那个好看的小哥哥（花痴脸红）。当然不是因为他长得好看，是因为之前的男生看错考号了。</p>
<p>开始考试之前检查C盘的状态，记得教练说过要是你自己看完了，你就找监考老师，装憨，让他帮你看看调对了没有，这样比较保险。所以我就憨憨的叫了老师过来看，老师检查了一下是对的就走了。<br>
这个时候旁边的小哥哥一头忙碌，他是真的没搞懂。于是我在线指导了一下，老师也过来看了一下，最后还是搞对了，小哥哥非常有礼貌的回了一句“谢谢”。啊怎么长的好看的人声音也这么好听啊www（花痴脸红），偷偷看了眼，他不是我们中学的，貌似姓刘，但是准考证一眼就晃过去了，也不知道到底别人是不是姓刘。</p>
<p><strong>然后开始考试。</strong></p>
<p>T1，看到我就笑了，string秒的，所有样例过了。</p>
<p>T2，比较清楚怎么做的，大概就是一个结构体数组，开始的时候觉得很简单，就随便敲的，但是后来发现样例一直过不了，就搁那儿一直调，最后两个小样例过了，大样例炸了。</p>
<p>T3，很认真的花了时间手撸样例，打了一堆工整的草稿（平常我的草稿绝对狂野风，但是今天心情比较平静，又有喜欢的太阳，又很舒适的理清了思路，旁边还有好看的小哥哥，酥服），理清了题目，大概明白就是像股市一样的操作，但是不太会写，就只骗了T=1的分。</p>
<p>T4，读了下题，觉得应该是图或者树之类的操作，还没学就没管了。<br>
剩下的时间都在调T2和发呆。</p>
<p>中途发了矿泉水，莫得小面包（生气状）。那瓶没喝完回去被当做珍宝一样怎么都舍不得喝，空瓶子也舍不得扔。最后它在其他矿泉水的混淆视听中被丢掉了。</p>
<p>整T2的时候教练进了我们考场和监考老师问了几句，顺便看了几眼。我坐在离门最近的位置，看到他刚想条件反射的叫一声，结果马上回忆起来大家在考场门前的约定，并且教练用眼神也示意我千万不要叫他。于是乎我到嘴边的“d老师！”就变成了口水被我吞进了肚子里。<br>
现在想起来可真是惊险啊，真的就差一点点吼出来。。。</p>
<p>考试过程中最担心的就是freopen写对没有，特别害怕把r和w写反导致抱灵。检查了很多遍，最后还是没有错。考试最后10分钟的时候去了freopen的注释，反复保存cpp文件。</p>
<p>最后交卷的时候已经比较不耐烦了，因为根本做不出来了。很轻松的离开了座位，去拿自己的背包。那天的草稿纸、被揉的都要烂掉的比赛注意事项、准考证，现在都静静地压在我的桌子底下。</p>
<p>怎么说呢，就和自己预估的差不多吧。</p>
<h3 id="复赛in-end">复赛in end</h3>
<p>复赛结束出来，爹来接我，我就如是说考得一般，也就那样。<br>
当时其实是比较悲观的，以为自己连3=都没有，事实上，T1过了的都有奖。</p>
<p>最后的分出来，2=，140=100+10+30+0。玄学，玄学。<br>
大家大部分也没有1=，基本都是2=。但有一位大佬以250的美妙分数得到了1=，真是tql！%%%%</p>
<hr>
<p>开始以为NOIP死了，没想到成为绝版的竟然是CSP。这段记忆我已经好好珍藏了。</p>
<p>OI魔芋，奥利给！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1562 丑数]]></title>
        <id>https://MrContinue.github.io/post/bsoj1562-chou-shu/</id>
        <link href="https://MrContinue.github.io/post/bsoj1562-chou-shu/">
        </link>
        <updated>2020-04-11T10:17:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586601109418.jpg" alt="" loading="lazy"></figure>
<h2 id="description"><strong>Description</strong></h2>
<pre><code>丑数是指素因子都在集合{2,3,5,7}内的整数，第一个丑数是1。
现在输入n(n&lt;=4000)，输出第n个丑数。
</code></pre>
<h2 id="input"><strong>Input</strong></h2>
<pre><code>输入文件仅一行为一个整数n。
</code></pre>
<h2 id="output"><strong>Output</strong></h2>
<pre><code>输出文件仅一行为一个整数，表示第n个丑数。
</code></pre>
<h2 id="sample-input"><strong>Sample Input</strong></h2>
<pre><code>5
</code></pre>
<h2 id="sample-output"><strong>Sample Output</strong></h2>
<pre><code>5
</code></pre>
<hr>
<h3 id="这道题窝先打的stl优先队列-然后全wa"><strong>这道题窝先打的STL优先队列 然后全WA。。。。</strong></h3>
<p>看了前辈的<strong>打表程序</strong> 对拍了一下 发现很有问题（废话</p>
<p>后来发现问题出在 <strong>丑数集合中不能有重复数字</strong></p>
<p>即 <strong>一个相同的数可能被视作多个数</strong></p>
<p>于是乎就短暂的考虑了<strong>桶</strong>。。。。</p>
<p>当开始试验的时候憨憨癌发作 以为数组只用开4000就OK</p>
<p>后来发现事情没那么简单。。。。。</p>
<p><strong>这个桶应该开到第4000个丑数的值那么大</strong></p>
<p>前辈的打表程序发现是<strong>2亿多</strong>。。。。。。</p>
<p><strong><s>（MLE的芳香！</s></strong></p>
<p>于是飞快放弃了。。。。</p>
<p>最后选用的是<strong>C++自带的超强的set函数</strong></p>
<p>先上网自学了一波 知道了<strong>set函数具有去重+排序的美妙功能</strong></p>
<p><strong>非常符合这道题的要求啊！</strong></p>
<p>于是自学set过后A了这道水题。。。。。。</p>
<p><strong>果然还是窝太菜了QAQ</strong></p>
<h3 id="set效率很高的-不愧是c">set效率很高的 不愧是C++</h3>
<p><a href="https://www.cnblogs.com/caiyishuai/p/8646345.html">自学set的文章网址</a></p>
<p>然后就是<strong>0ms</strong>AC代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt; 

#define maxn 1005
using namespace std;

set &lt;int&gt; a; 

int main()
{
	a.insert(1);
    //先插入堆顶操作元素
	int n;
	cin&gt;&gt;n;
	for(int i=2;i&lt;=n;i++)
    //因为初始化堆顶视为一次操作 所以从i=2开始
	{
		int num=*a.begin();
        //先定义一个变量储存当前堆顶
        //其实和指针没关系的。。。。
		a.insert(num*2);
        //分别插入操作数 set会自行排序维护根堆
		a.insert(num*3);
		a.insert(num*5);
		a.insert(num*7);
		a.erase(a.begin());
        //再将堆顶弹出
	}
	cout&lt;&lt;*a.begin()&lt;&lt;endl;
    //最后的堆顶就是答案啦~~~
	return 0;
}
</code></pre>
<p>有什么疑问可以问窝 但是窝很菜的。。。</p>
<p><s>CSP普及才Au宁敢问吗</s></p>
<hr>
<h3 id="2020年2月9日1019更新">2020年2月9日10:19更新</h3>
<p>在听了did讲课过后 窝知道了<strong>这道题其实可以不用set 而且没必要</strong></p>
<p><s>毕竟这就是一道堆练习嘛</s></p>
<p>窝再梳理了一下我的心路历程 发现实际上窝离正<s>常</s>确方法就差那么一丢丢</p>
<p>这道题的确要考虑到<strong>去重</strong></p>
<p>但没有必要用set去重 因为正如did所说的一样：</p>
<pre><code>“宁现在用了set，以后不能用set的时候宁怎么办？”
</code></pre>
<p>所以<strong>可以直接在堆的代码里加入少量的<s>盐</s>去重算法以达到同样效果</strong></p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

#define maxn 1005
using namespace std;

priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; a;
//定义一个小根堆
//这里使用的食材（bushi）工具是STL
//各位大佬可以自己手写堆 勿喷蒟蒻

int main()
{
	a.push(1);
	int n;
	cin&gt;&gt;n;
	for(int i=2;i&lt;=n;i++)
	{ 
		int num=a.top();
        //拿出堆顶元素 即操作数
		a.push(num*2);a.push(num*3);
        //放入其他丑数
		a.push(num*5);a.push(num*7);
		while(a.top()==num) a.pop();
        //去重 只要相同就pop
	}
	cout&lt;&lt;a.top()&lt;&lt;endl;
    //最后的堆顶就是第n个丑数啦~~~
	return 0;
}
</code></pre>
<h2 id="提交过后性能分析">提交过后性能分析</h2>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:right">Time</th>
<th style="text-align:right">Memory</th>
<th style="text-align:right">Length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">堆</td>
<td style="text-align:right">0ms</td>
<td style="text-align:right">1863KB</td>
<td style="text-align:right">0.39KB</td>
</tr>
<tr>
<td style="text-align:right">set</td>
<td style="text-align:right">0ms</td>
<td style="text-align:right">1997KB</td>
<td style="text-align:right">0.34KB</td>
</tr>
</tbody>
</table>
<p><strong>综上分析 堆更优</strong></p>
<p>堆的好处：易懂 易想 耗时较少</p>
<p>set的好处：好写 方便 码量较少</p>
<hr>
<h2 id="求点赞qaq不容易啊">求点赞QAQ不容易啊</h2>
<pre><code>常见疑问一：
OI上可以用set吗？
回答：
应该可以 但我没用过（
常见疑问二：
你BB太多 可以举报吗？
回答：
QAQ！！！不看就行啦！！！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1495 拾垃圾的机器人3541]]></title>
        <id>https://MrContinue.github.io/post/bsoj1495-shi-la-ji-de-ji-qi-ren-3541/</id>
        <link href="https://MrContinue.github.io/post/bsoj1495-shi-la-ji-de-ji-qi-ren-3541/">
        </link>
        <updated>2020-04-11T10:16:51.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://MrContinue.github.io/post-images/1586601026074.jpg" alt="" loading="lazy"><br>
<s>（did说，这是形容一个人很乖巧的词语）</s></p>
<h2 id="description">Description</h2>
<pre><code>有一块地被划分成了n*m个区域，在一些区域里有垃圾要拾捡。
现在科研人员开发了一个能捡垃圾的机器人，机器人每一次都可以移动一个区域的距离。
假设机器人从最左上区域出发，他每次只能向右或者向下走。
每次他到达一个点，就会自动把这个点内的垃圾拾掉。
问：该机器人最多能够拾多少垃圾？
在最多情况下，有多少种方案？
</code></pre>
<h2 id="input">Input</h2>
<pre><code>输入文件的第一行为两个整数n和m；
接下来有一个n*m的01矩阵。
矩阵中的第i行j列的数字a[i][j]=0表示为空地。
a[i][j]=1表示为垃圾。
</code></pre>
<h2 id="output">Output</h2>
<pre><code>输出两行，第一行为一个数字表示最多拾到的垃圾，第二行为一个数字表示在最多情况下，有多少种方案。
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>3 3
100
000
010
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>2
3
</code></pre>
<h3 id="今天也是菜得水3级题的一天呢"><s>今天也是菜得水3级题的一天呢</s></h3>
<p>因为机器人只能向下和向右走，满足无后效性。</p>
<p>所以我们考虑用DP作答。</p>
<p>首先，从<strong>输入上</strong>就有那么一个小小的坑<s>就只有我觉得是坑吧</s>，请大家研究一下矩阵的输入。</p>
<p><strong>科科，是没有空格的。</strong></p>
<p>所以我们要用string或者char数组来读入~</p>
<p>接着分析题意。</p>
<p>对于题目中的<s>人工智障</s>机器人，<strong>它到一个点的路径只有两<br>
种：从上来或者从左来。</strong></p>
<p>也就是说，对于题目中的<strong>点a[i][j]</strong>，它只可能源于<strong>点a[i-1][j]<strong>与</strong>点a[i][j-1]</strong>。</p>
<p>这点理清了，下面就可以顺理成章地理解了。</p>
<h2 id="一求最多捡到的垃圾">一：求最多捡到的垃圾</h2>
<p>我们可以用f[i][j]来统计<strong>捡到的最多垃圾数</strong>。由<strong>加法原理</strong>得出，<strong>f[i][j]=f[i-1][j]+f[i][j-1]</strong>。</p>
<p>实现代码：</p>
<pre><code class="language-cpp">//DP求最多拾到的垃圾 
for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
</code></pre>
<p>这样下来，f[n][m]就是到达终点时捡到的最多垃圾数。即我们要的答案。</p>
<h2 id="二求在最多情况下有多少种方案">二：求在最多情况下，有多少种方案？</h2>
<p>我们可以用q[i][j]来统计f最大时的方案数。</p>
<p>可得**有q[i][j]=q[i-1][j]<em>C1+q[i][j-1]<em>C2。</em></em></p>
<p>其中，<strong>若f[i-1][j]+a[i][j]==f[i][j]，则C1=1，反之为0</strong>；</p>
<p><strong>若f[i][j-1]+a[i][j]==f[i][j]，则C2=1，反之为0；</strong></p>
<p>但是这样做还有一个问题：<strong>边界值的问题。</strong></p>
<p>对于矩阵来说，最上和最右的点，是一定可以到达的。<strong>所以，我们可以把它们的初值赋为1。</strong></p>
<p>这样一来，我们的计算式子不仅有了初始值，还没有了越界的漏洞。</p>
<p>实现代码：</p>
<pre><code class="language-cpp">//DP求路径数 
for(int i=1;i&lt;=n;i++)
{
	q[1][i]=1;
	q[i][1]=1;		
}
//边界赋初值 
for(int i=2;i&lt;=n;i++)
	for(int j=2;j&lt;=m;j++)
	{
		long long C1,C2;
		if(f[i-1][j]+a[i][j]==f[i][j])
			C1=1;
		else C1=0;
		if(f[i][j-1]+a[i][j]==f[i][j])
			C2=1;
		else C2=0;
		q[i][j]+=q[i-1][j]*C1+q[i][j-1]*C2;
	}
</code></pre>
<hr>
<p><em><strong>似乎</strong></em> 一切都功德圆满了。</p>
<p>等等，你有看到窝的加粗嘛？</p>
<p>当初<s>自信的</s>可怜的continue就是这样WA的。。。。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/sqy2tbip.png" alt="" loading="lazy"></figure>
<p>在<strong>一群乐于助蒻的大佬</strong>指导下，窝当时整个人就一懵的。</p>
<h2 id="没错本题最重要的部分不在前面">没错，本题最重要的部分不在前面。</h2>
<h1 id="其实最重要的是">其实，最重要的是</h1>
<h1 id="开-long-long">开 long long 。 。 。 。 。</h1>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/hgpfg590.png" alt="" loading="lazy"></figure>
<p>惊不惊喜？</p>
<p>完整代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

#define maxn 105
using namespace std;

string s[maxn];
long long a[maxn][maxn]; //a数组表示矩阵 
long long f[maxn][maxn]; //f数组表示当前捡的最多垃圾数 
long long q[maxn][maxn]; //g数组表示f最大时的方案数 

int main()
{
	long long n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;s[i];
		for(int j=1;j&lt;=m;j++)
			a[i][j]=s[i][j-1]-'0';	
	}

	//DP求最多拾到的垃圾 
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
	cout&lt;&lt;f[n][m]&lt;&lt;endl;
	
	//DP求路径数 
	for(int i=1;i&lt;=n;i++)
	{
		q[1][i]=1;
		q[i][1]=1;		
	}
	//边界赋初值 
	for(int i=2;i&lt;=n;i++)
		for(int j=2;j&lt;=m;j++)
		{
			long long C1,C2;
			if(f[i-1][j]+a[i][j]==f[i][j])
				C1=1;
			else C1=0;
			if(f[i][j-1]+a[i][j]==f[i][j])
				C2=1;
			else C2=0;
			q[i][j]+=q[i-1][j]*C1+q[i][j-1]*C2;
		}
	cout&lt;&lt;q[n][m]&lt;&lt;endl;
	return 0;
}

</code></pre>
<hr>
<p><strong>QAQ求点赞</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1515 无限硬币问题]]></title>
        <id>https://MrContinue.github.io/post/bsoj1515-wu-xian-ying-bi-wen-ti/</id>
        <link href="https://MrContinue.github.io/post/bsoj1515-wu-xian-ying-bi-wen-ti/">
        </link>
        <updated>2020-04-11T10:16:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586600995814.png" alt="" loading="lazy"></figure>
<h2 id="description">Description</h2>
<pre><code>输入硬币的n种不同面值(各种面值的硬币个数不限)和m。
输出构成1到m元的最少硬币数。
</code></pre>
<h2 id="input">Input</h2>
<pre><code>第一行两个数n(n&lt;=200),m(m&lt;=10000)
第二行n个面值
</code></pre>
<h2 id="output">Output</h2>
<pre><code>共m行，每行为组成该值所需最少硬币数(若不能组成则输出-1)
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>3 4
1 2 3
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>1
1
1
2
</code></pre>
<hr>
<p><s>我太菜了，又来水DP基础题QAQ</s></p>
<p>这是一道DP的water problem</p>
<p>是美妙的背包啊~</p>
<hr>
<h2 id="一状态与定义">一：状态与定义</h2>
<p>f[i]表示凑齐i元所需的最少硬币数。</p>
<h2 id="二状态转移">二：状态转移</h2>
<p>当我们并没有计算过当前的硬币数时，<strong>用（i-a[j]）元时的硬币数+1</strong>（这个1就是减的那一个硬币值a[j]）。</p>
<p>而当我们已有了一个当前最小硬币数时，<strong>则将其与上一阶段最小硬币数小比较，取min。</strong></p>
<p>具体的公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mi>a</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo><mo>+</mo><mn>1</mn><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mi>a</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>!</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x) =
\begin{cases}
f[i-a[j]]+1 \qquad &amp; f[i]==0 \\
min(f[i],f[i-a[j]]+1) \qquad &amp; f!=0
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>0&lt;=i&lt;=m ; 1&lt;=j&lt;=n。</p>
<h2 id="三初始化">三：初始化</h2>
<p>f[i]=0；</p>
<h2 id="代码">代码</h2>
<p>※由于我们的状态定义是直接储存的答案，所以直接输出啦~</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 10010
using namespace std;

int a[maxn];
int f[maxn];

int main()
{
	int n,m;
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]); //输入硬币值 
	for(int i=0;i&lt;=m;i++)
		for(int j=1;j&lt;=n;j++)
			if(i&gt;=a[j]) //这里要判断一下 不然等会会越界 
			{
				if(f[i]==0) f[i]=f[i-a[j]]+1;
				else f[i]=min(f[i],f[i-a[j]]+1);				
			}
	for(int i=1;i&lt;=m;i++)
		printf(&quot;%d\n&quot;,f[i]); 
	return 0;
}

</code></pre>
<hr>
<h6 id="希望各位喜欢-求点赞qaq">希望各位喜欢 求点赞QAQ</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1527 盖房子(1697)]]></title>
        <id>https://MrContinue.github.io/post/bsoj1527-gai-fang-zi-1697/</id>
        <link href="https://MrContinue.github.io/post/bsoj1527-gai-fang-zi-1697/">
        </link>
        <updated>2020-04-11T10:15:46.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586600965636.jpg" alt="" loading="lazy"></figure>
<h2 id="description">Description</h2>
<pre><code>永恒の灵魂最近得到了面积为n*m的一大块土地（高兴ING^_^），他想在这块土地上建造一所房子.
这个房子必须是正方形的。
但是，这块土地并非十全十美，上面有很多不平坦的地方（也可以叫瑕疵）。
这些瑕疵十分恶心，以至于根本不能在上面盖一砖一瓦。
他希望找到一块最大的正方形无瑕疵土地来盖房子。
不过，这并不是什么难题，永恒の灵魂在10分钟内就轻松解决了这个问题。
现在，您也来试试吧。
</code></pre>
<h2 id="input">Input</h2>
<pre><code>输入文件第一行为两个整数n,m（1&lt;=n,m&lt;=1000），接下来n行，每行m个数字，用空格隔开。0表示该块土地有瑕疵，1表示该块土地完好。
</code></pre>
<h2 id="output">Output</h2>
<pre><code>一个整数，最大正方形的边长。
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>4 4
0 1 1 1
1 1 1 0
0 1 1 0
1 1 0 1
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>2
</code></pre>
<hr>
<p><s>我觉得我应该给自己起个霸气的外号，比如水中贵族，或者淼淼之类的。。。</s></p>
<p>今天也是水3级题的一天呢！ヾ(◍°∇°◍)ﾉﾞ</p>
<hr>
<p>这是一道DP水题。</p>
<p>题干太二（bushi）长了，简单的概括一下题意：</p>
<p><strong>给你一个由0和1组成的矩阵，让你在该矩阵中找到一个最大正方形，这个正方形是完全由1组成的，然后输出它的边长。</strong></p>
<p>接着开始<s>推理</s>分析。</p>
<hr>
<h2 id="一状态和定义">一：状态和定义</h2>
<p><strong>f[i][j]表示以（i,j）为右下角盖房子的最大边长。</strong></p>
<h2 id="二状态转移">二：状态转移</h2>
<p><strong>在a[i][j]==1的前提下，f[i][j]=min{f[i-1][j],f[i][j-1],f[i-1][j-1]}。</strong></p>
<p>为什么<strong>取min</strong>而不是max呢？题目不是要求的是最大边长吗？</p>
<h3 id="好问题">好问题。</h3>
<p>did曾经作为一个哲♂学老师教导过我们：</p>
<pre><code>看你们的 掌握情况 ，就要根据 没有那么听懂的人 来制定下一步的学习计划。这就是哲♂学中所讲的木桶原理。

一个木桶能装多少水取决于最短的那根木板。
</code></pre>
<p>所以这个故事告诉我们什么呢？<s>要当憨憨！</s></p>
<p>当前f[i][j]的值应该取决于<strong>最短的那个木板</strong>，也就是<strong>最小的关联值啦</strong>~</p>
<p>所以这里会取min呢~</p>
<h2 id="代码部分细节完善">代码&amp;&amp;部分细节完善</h2>
<p>由于这里的状态定义并不是最终答案，所以还要定义一个ans来储存最大边长。</p>
<p><strong>这个时候一定要取max！</strong> 注意取min和max要灵活！！！</p>
<p>其他的没什么了吧。就是代码啦（代码里面没有太多注释，该说的上面都说啦）：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
using namespace std;

int a[maxn][maxn];
int f[maxn][maxn]; 

//这里为了方便使用了一个函数来计算三个数的最小值 
int MinThree(int a,int b,int c)
{
	return min(a,min(b,c));
}

int main()
{
	int n,m;
	cin&gt;&gt;n&gt;&gt;m; 
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			cin&gt;&gt;a[i][j];
	int ans=-0x3f3f3f;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(a[i][j]==1)
			{
				f[i][j]=MinThree(f[i-1][j],f[i][j-1],f[i-1][j-1])+1;				
				ans=max(ans,f[i][j]); 
			}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}

</code></pre>
<p>撒花~✿✿ヽ(°▽°)ノ✿</p>
<hr>
<h6 id="喜欢就点个赞嘛qaq">喜欢就点个赞嘛QAQ</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1533 战略游戏1111]]></title>
        <id>https://MrContinue.github.io/post/bsoj1533-zhan-lue-you-xi-1111/</id>
        <link href="https://MrContinue.github.io/post/bsoj1533-zhan-lue-you-xi-1111/">
        </link>
        <updated>2020-04-11T10:15:05.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586600912389.gif" alt="" loading="lazy"></figure>
<h2 id="description">Description</h2>
<pre><code>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。
他要建立一个古城堡，城堡中的路形成一棵树。
他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。
请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵。
</code></pre>
<h2 id="input">Input</h2>
<pre><code>输入文件中数据表示一棵树，描述如下：
第一行 N，表示树中结点的数目。
第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)，接下来k个数，分别是每条边的另一个结点标号r1，r2，...，rk。
对于一个n(0 &lt; n &lt;= 1500)个结点的树，结点标号在0到n-1之间，在输入文件中每条边只出现一次。
</code></pre>
<h2 id="output">Output</h2>
<pre><code>输出文件仅包含一个数，为所求的最少的士兵数目。
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>4
0 1 1
1 2 2 3
2 0
3 0
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>1
</code></pre>
<hr>
<p>**树形DP！**直切思路！</p>
<hr>
<h2 id="一状态和表示">一：状态和表示</h2>
<p>设f[i][1]表示i点放士兵时，以i为根的子树需要的 最少士兵数目。</p>
<p>f[i][0]表示i点不放士兵时，以i为根的子树需要的最少士兵数目。</p>
<h2 id="二状态转移">二：状态转移</h2>
<p>当点i不放时，则它的所有儿子都必须放，即f[i][0]+=f[j][1]。其中j为i的儿子。</p>
<p>当点i放时，则它的所有儿子放与不放无所谓，但应该取两种情况的最小值。即 f[i][1]+=min(f[j][1],f[j][0])。</p>
<p>其中j为i的儿子。 初始条件：<strong>f[i][0]=0;f[i][1]=1。</strong></p>
<h2 id="代码细节完善">代码&amp;&amp;细节完善</h2>
<p>注意的点如下：</p>
<ul>
<li>
<p>平常就要注意的是结构体数组一定要<strong>开两倍！！</strong></p>
</li>
<li>
<p>平常也要注意像本题这种无向的话<strong>连边连2次</strong></p>
</li>
<li>
<p>这里Dfs是从（0，-1）开始的</p>
</li>
<li>
<p>是取的min值，注意读题</p>
</li>
</ul>
<p>上代码！</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1505
using namespace std;

struct node
{
	int to,next;
}a[maxn&lt;&lt;1];

int f[maxn][2];
int head[maxn];
int cnt;
int num[maxn];

void AddEdge(int x,int y)
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	head[x]=cnt;
}

void Dfs(int x,int prt)
{
	f[x][1]=1;
	for(int i=head[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(y==prt) continue;
		Dfs(y,x);
		f[x][0]+=f[y][1];
		f[x][1]+=min(f[y][0],f[y][1]);
	}
}

int main()
{
	int n;
	cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
	{
		int x;
        cin&gt;&gt;x;
        cin&gt;&gt;num[x];
        for(int j=1;j&lt;=num[x];j++)
		{
			int y;
            cin&gt;&gt;y;
            AddEdge(x,y);
            AddEdge(y,x);
        }
    }
    Dfs(0,-1);
    int ans=min(f[0][0],f[0][1]);
    cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}

</code></pre>
<hr>
<h6 id="写题解不易-求点赞qaq">写题解不易 求点赞QAQ</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1569 关押罪犯2809]]></title>
        <id>https://MrContinue.github.io/post/bsoj1569-guan-ya-zui-fan-2809/</id>
        <link href="https://MrContinue.github.io/post/bsoj1569-guan-ya-zui-fan-2809/">
        </link>
        <updated>2020-04-11T10:11:10.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586600584911.gif" alt="" loading="lazy"></figure>
<h2 id="description">Description</h2>
<pre><code>S城现有两座监狱，一共关押着N名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。
我们用“怨 气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。
如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。
每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S城Z市长那里。
公务繁忙的Z市长只会去看列表中的第一个事件的影响力， 如果影响很坏，他就会考虑撤换警察局长。
在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。
假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。
那么，应如何分配罪犯，才能使Z市长看到的那个冲突事件的影响力最小？这个最小值是多少？
</code></pre>
<h2 id="input">Input</h2>
<pre><code>输入文件名为 prison.in。输入文件的每行中两个数之间用一个空格隔开。
第一行为两个正整数N和M，分别表示罪犯的数目以及存在仇恨的罪犯对数。
接下来的M行每行为三个正整数 aj，bj，cj，表示aj号和bj号罪犯之间存在仇恨，其怨气值为cj。数据保证1≤aj
</code></pre>
<h2 id="output">Output</h2>
<pre><code>输出文件prison.out共1行，为Z市长看到的那个冲突事件的影响力。如果本年内监狱 中未发生任何冲突事件，请输出0。
</code></pre>
<h2 id="sample-input">Sample Input</h2>
<pre><code>4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884
</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>3512
</code></pre>
<h2 id="hint">Hint</h2>
<pre><code>【输入输出样例说明】
罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件 影响力是3512（由2号和3号罪犯引发）。
其他任何分法都不会比这个分法更优。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/03/01/3cln8e.png" alt="" loading="lazy"></figure>
<pre><code>【数据范围】
对于30%的数据有N≤15。
对于70%的数据有N≤2000，M≤50000。
对于100%的数据有N≤20000，M≤100000。
</code></pre>
<hr>
<p>这里是<strong>并查集</strong>做法（二分图什么的我就是太菜了QAQ）</p>
<hr>
<p>首先请先回忆一下并查集的几个基本操作：</p>
<h2 id="一并查集基本操作">一：并查集基本操作</h2>
<h3 id="1初始化">1.初始化</h3>
<p>在最开始时，每个节点的根应初始化为自己。</p>
<pre><code>for(int i=1;i&lt;=n;i++)
	prt[i]=i;
</code></pre>
<h3 id="2找根">2.找根</h3>
<p>思路：寻找当前元素的原始根节点（就是寻找它最爸爸的爸爸），然后return一下就行。</p>
<p>记住要压缩一下哦~</p>
<pre><code>int GetFather(int x)
{
	if(prt[x]==x) return x; //如果自己是自己的根，那就说明这是最原始的根节点，这个节点没有自己的父亲了，返回这个根
	prt[x]=GetFather(prt[x]); //压缩一下，找父亲
	return prt[x]; //返回父亲的值
}
</code></pre>
<h3 id="3连根">3.连根</h3>
<p>只需要找到两个操作元素的根，然后再让其中一个根成为另一个根的儿子即可。</p>
<pre><code>void AddEdge(int x,int y)
{
	int f1=GetFather(x); //找根
	int f2=GetFather(y);
	prt[f1]=f2; //让其中一个根节点成为另一个的儿子
}
</code></pre>
<h3 id="4查找">4.查找</h3>
<p>查找是否是同一个根。</p>
<pre><code>bool Search(int x,int y)
{
	int f1=GetFather(x); //找根
	int f2=GetFather(y);
    if(f1==f2) return true; //一个根就返回真值
    return false; //否则返回假值
}
</code></pre>
<h2 id="二思路">二：思路</h2>
<p>先<strong>从大到小</strong>将罪犯的怨气值排序。</p>
<p>接着请回忆一下<strong>团伙</strong>这道题。里面有提到一个关键的点。</p>
<pre><code>我敌人的敌人是我的朋友
</code></pre>
<p>于是乎，我们决定尝试罪犯1同罪犯2的<strong>敌人</strong>放到同一个监狱。如果能保证同一个监狱的两个罪犯是相对的<strong>朋友</strong>，那此时的怨气值一定是最小的。如果存在这样的分法，直接输出。</p>
<p>绕绕的，您多品品。</p>
<h2 id="三代码">三：代码</h2>
<p>对代码中变量的一些解释：</p>
<ul>
<li>Edge[]储存两个罪犯及其怨气值</li>
<li>prt[]储存父节点</li>
<li>en[]储存敌人</li>
</ul>
<p>上代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define maxn 100010
using namespace std;

struct Edge
{
	int pre1,pre2;
	int v;
}a[maxn];

int prt[maxn];
int en[maxn];

int GetFather(int x)
{
	if(prt[x]==x) return x;
	prt[x]=GetFather(prt[x]);
	return prt[x]; 
}

void AddEdge(int x,int y)
{
	int f1=GetFather(x);
	int f2=GetFather(y);
	prt[f1]=f2; 
}

bool Search(int x,int y)
{
	int f1=GetFather(x);
	int f2=GetFather(y);
    if(f1==f2) return true;
    return false;
}

bool cmp(Edge x,Edge y)
{
	return x.v&gt;y.v;
}

int main()
{
	int n,m;
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		prt[i]=i;
	for(int i=1;i&lt;=m;i++)
		scanf(&quot;%d %d %d&quot;,&amp;a[i].pre1,&amp;a[i].pre2,&amp;a[i].v);
	sort(a+1,a+m+1,cmp);
	for(int i=1;i&lt;=m+1;i++)
	{
		int p1=a[i].pre1;
		int p2=a[i].pre2;
		if(Search(p1,p2))
		{
			printf(&quot;%d\n&quot;,a[i].v);
			return 0;
		}
		if(!en[p1]) en[p1]=p2;
		else AddEdge(en[p1],p2);
		
		if(!en[p2]) en[p2]=p1;
		else AddEdge(en[p2],p1);
	}
	return 0;
}
</code></pre>
<h6 id="喜欢请点个赞嘛qaq">喜欢请点个赞嘛QAQ</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BSOJ1626 网络（POJ1144）3596]]></title>
        <id>https://MrContinue.github.io/post/bsoj1626-wang-luo-poj11443596/</id>
        <link href="https://MrContinue.github.io/post/bsoj1626-wang-luo-poj11443596/">
        </link>
        <updated>2020-04-11T09:42:01.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://MrContinue.github.io/post-images/1586600642173.gif" alt="" loading="lazy"></figure>
<p>这是一道无向图连通性的模板题。</p>
<p>这道题求割点，唯一难点在于输入数据。。。真的被输入卡了很久。。。。</p>
<p>还有一个注意的点，就是在求割点的时候要注意**去重。**可以用一个flag数组标记一下。<s>在这个地方也卡了很久</s></p>
<p>剩下的东西在代码里也有所体现。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;cstring&gt;

#define maxn 1005
#define inf 0x7fffffff/2
using namespace std;

int in[maxn][maxn]; //入度
int DFN[maxn],LOW[maxn]; 
int prt[maxn];
int son;
int sum=0;
bool flag[maxn];

int cnt;
int t; //时间戳 
int n;

void Tarjan(int x)
{
	DFN[x]=LOW[x]=++t; //给x按照访问顺序的先后编号为t 及 给lou[x]赋初值
	for(int i=1;i&lt;=n;i++) //寻找一个x的相邻接点
		if(in[x][i]&amp;&amp;prt[x]!=i) //x到i右边且不是回边
			if(!DFN[i]) //i未被访问过
			{
				prt[i]=x; //则x是i的父亲
				Tarjan(i); //xi是父子边，递归访问i
				LOW[x]=min(LOW[i],LOW[x]); //所有儿子中最小值
				if(LOW[i]&gt;=DFN[x]&amp;&amp;!flag[x]) //这里判断割点，注意一定要记住去重
				{
					if(DFN[x]==1) //根
					{
						son++;
						if(son&gt;=2)
						{
							sum++;		
							flag[x]=1; //标记有统计过去重					
						}
					}
					else //x是割点
					{
						sum++;	
						flag[x]=1;		
					}				
				}
			}
			else LOW[x]=min(LOW[x],DFN[i]);		
            //若已访问则访问时间一定早于x，x i是返祖边
}
int main()
{
	while(1)
	{
    	//多组数据，一定要清零！
		memset(in,0,sizeof(in));
		memset(DFN,0,sizeof(DFN));
		memset(LOW,0,sizeof(LOW));
		memset(prt,0,sizeof(prt));
		memset(flag,0,sizeof(flag));
		son=0;
		cnt=0;
		t=0;
		sum=0;
		cin&gt;&gt;n;
		if(!n) break;
        //如果输入0，所有程序结束
		while(1)
		{
			int x;
			cin&gt;&gt;x;
			if(!x) break;
            //如果输入0，本组数据结束
			char ch;
			int num;
			while(1)
			{	
				cin&gt;&gt;num;				
				ch=getchar();
				in[num][x]=1;
				in[x][num]=1;				
				if(ch==' ') continue;
				if(ch=='\n') break;	//如果输入为换行，则进入下一组数据
			}
		}
		for(int i=1;i&lt;=n;i++)
			if(!DFN[i]) Tarjan(i);
		cout&lt;&lt;sum&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<p>撒花~✿✿ヽ(°▽°)ノ✿</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整理】DP模板题及知识点汇讲]]></title>
        <id>https://MrContinue.github.io/post/zheng-li-dp-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/</id>
        <link href="https://MrContinue.github.io/post/zheng-li-dp-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/">
        </link>
        <updated>2020-04-11T09:41:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="特别特别感谢">特别特别感谢：</h2>
<h3 id="lmpp"><a href="https://www.luogu.com.cn/user/160839">lmpp</a>大佬<strong>牺牲自己宝贵时间，为我没有脾气的耐心讲解。</strong></h3>
<h3 id="lmpp大佬的博客"><a href="https://www.luogu.com.cn/blog/160839/">lmpp大佬的博客</a>：墙裂建议进去康一康！</h3>
<h4 id="还有gmq-gbf同学感谢你们的鼓励与支持">还有gmq、gbf同学，感谢你们的鼓励与支持！！</h4>
<h4 id="did教给我知识真是太强了">did教给我知识真是太强了！！</h4>
<p>没有他们就没有这篇博客，我也会比现在蒻上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>倍。</p>
<hr>
<h3 id="提示">提示：</h3>
<p>本博客公开， <strong>但“例题部分”仅记录的是本人认为较有意义添加的题或者是本人的知识盲区。</strong> 我会以<strong>知识点为经，算法为纬</strong>，在知识点开头加入模板题并附有代码，有的时候会写一点小提示，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span>。</p>
<p>在我自己掌握特别不好的题目/知识点旁会加以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 的标记。</p>
<p><strong>所有题号以BSOJ为准。</strong></p>
<p>有什么错误纰漏的直接QQ+洛谷私信+讨论区留言，我真的超级需要您的反馈的qwq。</p>
<p>希望能您能从这份清单中找到您的一些知识漏洞并把他们补起来！</p>
<hr>
<h3 id="更新信息">更新信息</h3>
<p>2020.3.13 <strong>1.0版本</strong>，知识点记录至区间DP模板题</p>
<p>2020.3.16 <strong>1.1版本</strong>，知识点记录至树形DP模板题，添加了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>效果，优化了部分知识点的注释</p>
<p>2020.3.24 <strong>1.2版本</strong>，知识点记录至树形DP模板题，优化了部分知识点的注释。同时，在<strong>lmpp大佬</strong>的指导下，想起来了一些遗忘的知识点并作了一些添加。感谢！</p>
<p>2020.3.25 <strong>1.3版本</strong>，知识点记录至部分和问题，优化了部分知识点的注释及tips</p>
<p>2020.3.28 <strong>1.4版本，为了使每个知识点的理解更加深入，也为了使记录更佳方便，本博客主要记录内容改为“DP模板题及部分例题汇总”。</strong> 添加了树形DP模板题“树的重心”，优化了部分知识点的注释及tips</p>
<p>2020.3.19 <strong>1.45版本</strong>，主要是优化了博客的强调、标题等，优化了阅读感官效果，优化了部分知识点的注释及tips</p>
<hr>
<h2 id="模板题">模板题</h2>
<hr>
<h3 id="坐标dp">坐标DP：</h3>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1346">1346 数字金字塔</a></p>
<pre><code>//这份代码采用的是从上至下统计然后用ans储存最终最大值的方法
//顺推法
#include &lt;iostream&gt;
#include &lt;cmath&gt;

#define maxn 1005
using namespace std;

int a[maxn][maxn];
int f[maxn][maxn];
//f[i][j]表示位置为(i,j)的点的最大值

int main()
{
	int n;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=i;j++)
			cin&gt;&gt;a[i][j];
	f[1][1]=a[1][1];
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=i;j++)
		{
        	//对于一个值的来源有两种：
            //1.上一状态留下的最优值
            //2.当前最优值
            //所以我们只需要把两种状态的值相比较，得出最优值更新即可
			f[i+1][j]=max(f[i+1][j],f[i][j]+a[i+1][j]);
			f[i+1][j+1]=max(f[i+1][j+1],f[i][j]+a[i+1][j+1]);
		}
    //由于顺推法是将答案统一统计到最底层，所以在择取最优解时还需要再遍历一遍最底层求最优值
	int ans=-0x7ffffff;
	for(int i=1;i&lt;=n;i++)
		if(ans&lt;f[n][i]) ans=f[n][i];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr>
<h3 id="线型dp">线型DP：</h3>
<p>LCS：<a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1353">1353 最长公共子序列</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>子序列</strong>与<strong>子串</strong>的区别</p>
<p>最长公共<strong>子串</strong>（Longest Common Substirng）和最长公共<strong>子序列</strong>（Longest Common Subsequence，<strong>LCS</strong>）的区别为：子串是串的一个连续的部分，子序列则是从不改变序列的顺序，而从序列中去掉任意的元素而获得新的序列；也就是说，<strong>子串中字符的位置必须是连续的，子序列则可以不必连续。</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;

#define maxn 205
using namespace std;

string a,b;
int f[maxn][maxn];
//f[i][j]表示固定S1的第i项时与j的匹配情况

int main()
{
	cin&gt;&gt;a&gt;&gt;b;
	a=' '+a; b=' '+b;  //为了循环时从1开始比较方便，可以加一个' '
	for(int i=1;i&lt;a.length();i++)
		for(int j=1;j&lt;b.length();j++)
        	//如果当前字母能匹配上，则将上一阶段最长公共子序列的长度+1
			if(a[i]==b[j])
				f[i][j]=f[i-1][j-1]+1;
            //如果匹配不上，既无法添加到上一阶段最长公共子序列，直接将上一阶段中的最大值赋值
			else
				f[i][j]=max(f[i-1][j],f[i][j-1]);
	cout&lt;&lt;f[a.length()-1][b.length()-1]&lt;&lt;endl;
	return 0;
}

</code></pre>
<p>LIS：<a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1355">1355 最长上升子序列</a></p>
<pre><code>#include &lt;iostream&gt;

#define maxn 1005
using namespace std;

int a[maxn];
int f[maxn]; 
//f[i]表示以a[i]结尾的最长上升子序列的最大长度

int main()
{
	int n;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
		f[i]=1;
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;i;j++)
        	//首先判断是否满足【上升】条件
			if(a[i]&gt;a[j])
            //再判断是否【最长】，取最大长度值
            	f[i]=max(f[i],f[j]+1);
    //由于f数组的设计是【以a[i]结尾的】最长上升子序列的最大长度
    //所以我们并不能直接知道最终的答案，还要再遍历比较一下
	int ans=-0x3f3f3f;
	for(int i=1;i&lt;=n;i++)
		ans=max(ans,f[i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr>
<h3 id="背包">背包：</h3>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1364">1364 01背包问题</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>1. 01背包题意概括</strong></p>
<p>假定背包的最大容量为W，N件物品，每件物品都有自己的价值和重量，将物品<br>
放入背包中使得背包内物品的总价值最大。</p>
<p><strong>2. 01背包为什么叫01背包</strong></p>
<p>由于在该问题中，一个物品只有【放】与【不放】两种状态，刚好对应【0】与【1】的真假状态。由此得名01背包。</p>
<pre><code>//本代码是做过滚动数组优化的代码
//从二维优化到了一维

#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 205
using namespace std;

int f[maxn];
//f[i]表示背包容量为i时背包内物品价值的最大值
int v[maxn],c[maxn];
//v[i]表示第i件物品所需容量，c[i]表示第i件物品的价值

int main()
{
	int w,n;
	scanf(&quot;%d %d&quot;,&amp;w,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d %d&quot;,&amp;v[i],&amp;c[i]);
	for(int i=1;i&lt;=n;i++)
		for(int j=w;j&gt;=v[i];j--)
        //这里的第二重循环做过优化
        //w为总容量，由于我们在下面计算时需要用到【j-v[i]】，为了不出现数组越界，也为了增强效率，所以设置边界为【j&gt;=v[i]】
        //由于这里进行了压缩，为了不干扰到正常计算，所以使用倒序进行覆盖
			f[j]=max(f[j],f[j-v[i]]+c[i]);
            //尝试将该物品放入背包后的价值是否能大于上一状态遍历结果
	printf(&quot;%d\n&quot;,f[w]);
    //由于状态的定义，这里直接输出
	return 0;
}
</code></pre>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1365">1365 完全背包</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>完全背包</strong></p>
<p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
using namespace std;

int f[maxn];
//f[i]表示占用资源为i时的最大价值
int v[maxn],c[maxn];
//v[i]表示第i件物品所需容量，c[i]表示第i件物品的价值

int main()
{
	int w,n;
	scanf(&quot;%d %d&quot;,&amp;w,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d %d&quot;,&amp;v[i],&amp;c[i]);
	for(int i=1;i&lt;=n;i++)
		for(int j=v[i];j&lt;=w;j++)
        //由于无限物品，我们刚好可以利用滚动数组上一次循环的数据进行操作而不会受到限制，所以直接循环即可
			f[j]=max(f[j],f[j-v[i]]+c[i]);
	printf(&quot;max=%d\n&quot;,f[w]);
	return 0;
}
</code></pre>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1515">1515 无限硬币问题</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 10010
using namespace std;

int a[maxn];
int f[maxn];  //f[i]表示组成i元所需的最少硬币数

int main()
{
	int n,m;
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);   //如题义
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=0;i&lt;=m;i++)  //先枚举1~m的钱数
		for(int j=1;j&lt;=n;j++) //再枚举硬币数量
			if(i&gt;=a[j])  //必须要能【组成】i元钱
			//【组成】这个概念比较模糊 为您详细解释一下
			//这里的意思就是不能让该硬币的价值大于我们要求的价值
			//要让硬币组成价值
			{
				if(f[i]==0)  //如果之前没有统计过f[i]
				    f[i]=f[i-a[j]]+1;  //则f[i]为f[i-a[j]]+1
				//这里稍微解释一下为什么这么做
				//因为还没有本阶段的值，所以就选取上一阶段的值+1
				else f[i]=min(f[i],f[i-a[j]]+1);  //如果有统计过 则择取最小数		
			}
	for(int i=1;i&lt;=m;i++)
		printf(&quot;%d\n&quot;,f[i]); 
	return 0;
}
</code></pre>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1517">1517 有限硬币问题</a></p>
<pre><code>#include &lt;iostream&gt;

#define maxn 10005
using namespace std;

int f[maxn];  //f[i]表示组成i元所需的最少硬币数
int a[maxn],b[maxn];

int main()
{
	int m,n;
	cin&gt;&gt;n&gt;&gt;m; //如题义
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;a[i];
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;b[i];
	for(int i=1;i&lt;=m;i++)
		f[i]=0x3f3f3f; //这里要初始化为最大值
	//因为f[i]到时候会进行min操作 所以应该从最大开始
	//至于为什么1515不用初始化为最大 因为我们进行了一次判断操作 即if(f[i]==0)
	//因为【有限】的特殊性，我们不能直接if 所以这里需要初始化
	f[0]=0; //凑成0元是不需要硬币的 所以=0
	for(int i=1;i&lt;=n;i++)  //先枚举第i种硬币
		for(int k=1;k&lt;=b[i];k++)  //再枚举使用第i种硬币k枚
			for(int j=m;j&gt;=k*a[i];j--) //对产生的价值j优化
			//这里对第三重循环做一点点讲解
			//m代表目标价值，k*a[i]代表k枚a[i]价值的硬币总价值
			//之所以比1515多出来这个循环也是因为【有限】的特殊性
				f[j]=min(f[j],f[j-k*a[i]]+k);
				//这里就是比较凑成j元所需的最小硬币数
	for(int i=1;i&lt;=m;i++)
		if(f[i]==0x3f3f3f)  //如果凑不成i元 则输出-1
			cout&lt;&lt;-1&lt;&lt;endl;
		else  //输出凑成i元的最少硬币数
			cout&lt;&lt;f[i]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p>对于如何从<strong>无限硬币问题</strong>转换成<strong>有限硬币问题</strong>，之前与一位大佬进行了探讨，汇总如下，仅个人意见：</p>
<pre><code>……（前面的讨论主要是搭配代码进行了理解，可以直接看代码及注释）

窝看了下，这两者基本上就两处不同：
1. 1517要初始化 1515则不用
2. 1517多了一重优化循环
</code></pre>
<hr>
<h3 id="colorredcolorboxyellow-区间dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 区间DP：</h3>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1510">1510 最小最大代价子母树</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 105
using namespace std;

int a[maxn]; //原数组 
int f[maxn]; //前缀和数组 
int maxx[maxn][maxn],minn[maxn][maxn]; //最大最小数组 
//maxx[i][j]表示从第i堆石子到第j堆石子合并为一堆石子的最大代价（即最大子母树）
//minn[i][j]表示从第i堆石子到第j堆石子合并为一堆石子的最小代价（即最小子母树）

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
    //求前缀和，日常清空数组初始化
	for(int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1]+a[i];
		maxx[i][i]=0;
		minn[i][i]=0;
	}
	for(int x=1;x&lt;n;x++) //合并阶段
		for(int i=1;i&lt;=n-x;i++) //起点
		{
			int j=i+x; //当下起点的终点
			maxx[i][j]=-0x3f3f3f; //初始化
			minn[i][j]=0x3f3f3f;
			for(int z=i;z&lt;j;z++) //状态转移，求f[i][j]的最优值
			{
				maxx[i][j]=max(maxx[i][j],maxx[i][z]+maxx[z+1][j]);
				minn[i][j]=min(minn[i][j],minn[i][z]+minn[z+1][j]);
			}
            //累加当前合并需要的的代价
            //f[j]-f[i-1]表示f[i-1]~f[j]区间的和
			maxx[i][j]=maxx[i][j]+f[j]-f[i-1];
			minn[i][j]=minn[i][j]+f[j]-f[i-1];
		}
    //由于我们设计的数组，所以这里直接输出
    //minn[1][n]表示从第1堆石子到第n堆石子合并为一堆石子的最小代价（即最小子母树）
    //maxx[1][n]表示从第i堆石子到第j堆石子合并为一堆石子的最大代价（即最大子母树）
	printf(&quot;%d\n%d\n&quot;,minn[1][n],maxx[1][n]);
	return 0;
}
</code></pre>
<hr>
<h3 id="colorredcolorboxyellow-树形dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 树形DP：</h3>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1530">1530 加分二叉树</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 35
using namespace std;

int a[maxn];
int f[maxn][maxn];
//f[i][j]表示i~j的最高加分值
int p[maxn][maxn];
//p[i][j]表示i~j段的根节点

int Dp(int i,int j) //i~j作为一棵树的最高加分值
{
	if(i&gt;j) return 1; //i到j是一棵空树，返回1
	if(i==j) return a[i]; //i到j只有一个节点（即叶节点），返回本身的值
	if(f[i][j]&gt;0) return f[i][j]; //若曾经被遍历过，则直接返回其值
	for(int k=i;k&lt;=j;k++) //在i~j中枚举k是根
	{
		int t=Dp(i,k-1)*Dp(k+1,j)+a[k]; //递归求左右两边的总值
		if(t&gt;f[i][j]) //记录选择最优的根
		{
			f[i][j]=t; //保存当前的最高加分值
			p[i][j]=k; //记录根的序号
		}
	}
	return f[i][j];
}

void Out(int i,int j) //输出方案
{
	if(i&gt;j) return ; //i到j是一棵空树，返回
	if(i==j) //i到j只有一个节点（即叶节点），输出本身的值
	{
		printf(&quot;%d &quot;,i);
		return ;
	}
	printf(&quot;%d &quot;,p[i][j]); //由于是先序，所以先输出根
	Out(i,p[i][j]-1); //递归输出左子树
	Out(p[i][j]+1,j); //递归输出右子树
}

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	Dp(1,n); //遍历求结果
    //先输出最高加分值
	printf(&quot;%d\n&quot;,f[1][n]);
    //进入输出程序
	Out(1,n); 
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1529">1529 二叉苹果树</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>思路：</strong></p>
<p>由题意可知，需要保留的树枝数量为Q条，即保留结点t=Q+1个。树根必须保留，可以分三种情况讨论保留苹果的最大数：</p>
<ol>
<li>
<p>树根的左子树为空，全部保留右子树，右子树中保留（t-1）个结点；</p>
</li>
<li>
<p>树根的右子树为空，全部保留左子树，左子树中保留（t-1）个结点；</p>
</li>
<li>
<p>树根的两棵子树非空，设左子树保留k个结点，则右子树保留（t-k-1）个结点。</p>
</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p>对于memset的小坑点：</p>
<p>memset常用来作初始化，但由于它的填充方法是<strong>字节填充</strong>，所以这对它造成了一些局限性。<strong>它只能对数组统一赋一些特殊值。</strong></p>
<p>其中常用的赋值有：</p>
<ul>
<li>0</li>
<li>-1</li>
<li>0x3f</li>
<li>0x7f</li>
</ul>
<p>其中【赋值】指的是<strong>memset函数中填写的值</strong>。以0x3f为例，即：</p>
<pre><code>memset(a,0x3f,sizeof(a));
</code></pre>
<p>而实际上，a数组里的所有值已经全部变成了<strong>0x3f3f3f3f</strong>。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define maxn 105
using namespace std;

int ch[maxn][2]; //ch[v][1]、ch[v][2]分别储存节点v的左右孩子
int f[maxn][maxn]; //f[v][i]表示以v为根的树上保留i个节点的最大权值和
int num[maxn]; //num[i]表示i的子节点的苹果数
int a[maxn][maxn]; //输入数组
int n,q;

void BuildTree(int t) //建树
{
	for(int i=1;i&lt;=n;i++) //遍历子树
		if(a[t][i]&gt;=0) //如果存在该节点是当前节点子节点
		{
			ch[t][1]=i; //先储存子节点序号
			num[i]=a[t][i]; //再储存
			a[t][i]=-1; a[i][t]=-1; //标记已遍历过
			BuildTree(i); //继续遍历接下来的子树
			break; //这个节点访问完毕
		}
	for(int i=1;i&lt;=n;i++) //思路同上，两次循环分别是访问左、右子树
		if(a[t][i]&gt;=0)
		{
			ch[t][2]=i;
			num[i]=a[t][i];
			a[t][i]=-1; a[i][t]=-1;
			BuildTree(i);
			break;
		}
}

int DP(int v,int t) //求v为根的树上保留i个节点的最大权值和
{ 
	int i; 
	if(t==0) return 0;  //如果已经没有可以保留的节点，则return 0
	if((ch[v][1]==0)&amp;&amp;(ch[v][2]==0)) return num[v];  //如果访问到叶节点，则返回叶结点的值
	if(f[v][t]&gt;0) return f[v][t]; //记忆化搜索 f数组的初始值为-1
	for(i=0;i&lt;=t-1;i++) //遍历t种情况
		f[v][t]=max(f[v][t],DP(ch[v][1],i)+DP(ch[v][2],t-i-1)+num[v]);  //当前情况的最优值是左右孩子总的最优值
	return f[v][t]; //返回当前点的最优情况
}

int main()
{
	memset(f,-1,sizeof(f)); //将f数组赋初值为-1，以便接下来的记忆化操作
	cin&gt;&gt;n&gt;&gt;q;
	q++; //因为在二叉树中点数=边数-1，所以为了求出边数，就用点数q+1，也就是++，来进行操作
	for(int i=1;i&lt;n;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		a[x][y]=v;
		a[y][x]=v; //二叉树是无向的，一定要记得建双边
	}
	BuildTree(1); //从根节点1开始遍历
	cout&lt;&lt;DP(1,q)&lt;&lt;endl; //按照我们对DP函数的定义，直接输出DP(1,q)即可
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1532">1532 树的最长链1171</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>思路：</strong></p>
<p>设j是i的子节点，f1、f2数组定义见代码</p>
<ol>
<li>若f1[j]+1&gt;f1[i]，则f2[i]=f1[i]；f1[i]=f1[j]+1</li>
<li>否则，若f1[j]+1&gt;f2[i]，则f2[i]=f1[j]+1</li>
<li>最后扫描所有的节点，找最大的f1[i]+f2[i]的值</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mrow><mtext mathvariant="fraktur">后更のtips1</mtext><mtext> </mtext><mtext mathvariant="fraktur">plus：</mtext></mrow></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{后更のtips1 plus：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak cjk_fallback" style="color:CornflowerBlue;">后</span><span class="mord mathfrak cjk_fallback" style="color:CornflowerBlue;">更</span><span class="mord mathfrak cjk_fallback" style="color:CornflowerBlue;">の</span><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord" style="color:CornflowerBlue;"> </span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">l</span><span class="mord mathfrak" style="color:CornflowerBlue;">u</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak cjk_fallback" style="color:CornflowerBlue;">：</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p>在lmpp大佬的耐心讲解下，我又有了一点新的想法想补充呢qwq~</p>
<ol>
<li>为什么<code>f1[j]+1&gt;f1[i]，则f2[i]=f1[i]；f1[i]=f1[j]+1</code>？<br>
对于这个问题，我还可以顺便更细致地讲解一下做题思路。</li>
</ol>
<p><strong>首先，题目求的最长链，究竟是树的哪一个部分呢？</strong></p>
<p>下面这张图可以比较清晰的看出，树的最长链是<strong>由两条最长链，即此树的最长链和次长链链接而组成的。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/03/24/8OtV4x.png" alt="8OtV4x.png" loading="lazy"></figure>
<p>当子节点j能延伸出更长的链时，则可以将<strong>原来的次长链更新为以前的最长链（即<code>f2[i]=f1[i]</code>），再更新现在的最长链（即<code>f1[i]=f1[j]+1</code>）</strong></p>
<ol start="2">
<li>为什么<code>f1[j]+1&gt;f2[i]，则f2[i]=f1[j]+1</code>？</li>
</ol>
<p><strong>当现在的最长链大于以前次长链的长度时</strong>，就将当前次长链的长度替换成现在的最长链。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>前向星注意事项：</strong></p>
<ul>
<li>
<p>结构体数组一定要开双倍！这一点可能会直接导致RE or WA！结构体数组之所以要开双倍，是因为在二叉树或者无向图问题中，<strong>通常需要建双边来表示两点联通，所以负责储存的结构体数组需要开双倍</strong>。</p>
</li>
<li>
<p>关于结构体数组的叠加器cnt值是++cnt还是cnt++，这完全取决于定义与个人喜好。通常对于cnt=0的情况，我们会更乐意让cnt先做自增，即a[++cnt]。当然，也可以把cnt++放在操作外面进行，都是可以的。</p>
</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 200010
using namespace std;

struct node
{
	int to; //第i条边的终点
    int next; //与第i条边同起点的下一条边的储存位置
}a[maxn&lt;&lt;1]; //这里一定要注意开两倍，详见tips

int head[maxn]; //表示以i为起点的第一条边的存储位置
int f1[maxn]; //f1[i]表示以i为根的子树中，i到叶子节点的距离最大值
int f2[maxn]; //f2[i]表示以i为根的子树中，i到叶子节点的距离次大值
int prt[maxn]; //prt[i]表示节点i的父亲
int cnt; //结构体数组a的叠加器cnt
int n;

void AddEdge(int x,int y) //建边操作
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	head[x]=cnt;
}

void Dfs(int x)
{
	for(int i=head[x];i;i=a[i].next) //前向星遍历
	{
		int y=a[i].to; //找到a[i]的终点y
        if(y==prt[x]) continue; //如果y是我们要找的点的父亲，即有联系，则结束本次循环
        prt[y]=x; //否则，就将节点y连接到x身上，成为x的子节点
        Dfs(y); //接着遍历已经是子节点的y
        if(f1[y]+1&gt;f1[x]) //如果新添加的y节点能延伸出更长的链
        {
        	f2[x]=f1[x]; //则可以将原来的次长链更新为以前的最长链
        	f1[x]=f1[y]+1; //再更新现在的最长链
		}
		else if(f1[y]+1&gt;f2[x]) //当现在的最长链大于以前次长链的长度时
			f2[x]=f1[y]+1; //就将当前次长链的长度替换成现在的最长链
    }
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n-1;i++)
	{
		int qaq,qwq;
		scanf(&quot;%d %d&quot;,&amp;qaq,&amp;qwq);
		AddEdge(qaq+1,qwq+1); //建双边
		AddEdge(qwq+1,qaq+1); 
	}
	Dfs(1);
	int ans=-0x3f3f3f;
	for(int i=1;i&lt;=n;i++)
		ans=max(ans,f1[i]+f2[i]); //最后扫描所有的节点，找最大的f1[i]+f2[i]的值，也就是找最长链
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr>
<h3 id="colorredcolorboxyellow-部分和"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 部分和：</h3>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1356">1356 最大子矩阵问题</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>思路：</strong></p>
<p>最大子矩阵问题就是最大连续子序列和问题的提升，即<strong>将一条线换成一个面，将一维问题提升到二维问题</strong>。</p>
<p>我们可以想到：在一个一维的数列中，设数组b[i]表示从第1个元素到第i个元素的和，则如果想要求第i个元素到第j个元素的和，只需要计算b[j]-b[i-1]的值就行了。由此推广到二维矩阵，<strong>设b[i][j]表示矩阵第j列前i个元素的和，a[i][j]表示元素数据，则压缩存储：</strong></p>
<pre><code>for(i=1;i&lt;=n;i++)
	for(j=1;j&lt;=n;j++)
    {
    	cin&gt;&gt;a[i][j];
        b[i][j]=b[i-1][j]+a[i][j];
    }
</code></pre>
<p>因此，我们可以<strong>使用三重循环求出所有的矩形值，即枚举起始行i和终止行j，压缩子矩形成为一行，变成一维求最大字段和问题。</strong> 即：</p>
<pre><code>t[k]=max(t[k-1],0)+b[j][k]-b[i-1][k];

</code></pre>
<p><strong>（以上的tips【思路】均摘自did的PPT，由于阐述实在太到位了，自己也写不出来好的，所以直接引用学习了qwq）</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 305
using namespace std;

int a[maxn][maxn];
int b[maxn][maxn]; //b[i][j]表示矩阵第j列前i个元素的和，前缀和数组
int t[maxn]; //t[i]表示从数组最开始到i的和，前缀和优化数组

int main()
{
	int n;
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;a[i][j];
			b[i][j]=b[i-1][j]+a[i][j]; //前缀和累加过程
		}
	int ans=-0x3f3f3f;
	for(int i=1;i&lt;=n;i++) //阶段：起始行
		for(int j=i;j&lt;=n;j++) //状态：结束行
		{
			t[1]=b[j][1]-b[i-1][1]; //初始化第一列的值
			for(int k=2;k&lt;=n;k++) //决策：第几列
			{
				t[k]=max(t[k-1],0)+b[j][k]-b[i-1][k]; 						//max(t[k-1],0)：只要上一项不为负数，则直接加到当前值的累加中
                //+b[j][k]-b[i-1][k]：二维前缀和求矩阵数字和
				if(t[k]&gt;ans) ans=t[k]; //在操作时直接统计最大的矩阵和
			}
		}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整理】基础图论模板题及知识点汇讲]]></title>
        <id>https://MrContinue.github.io/post/zheng-li-ji-chu-tu-lun-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/</id>
        <link href="https://MrContinue.github.io/post/zheng-li-ji-chu-tu-lun-mo-ban-ti-ji-zhi-shi-dian-hui-jiang/">
        </link>
        <updated>2020-04-11T09:35:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="特别特别感谢">特别特别感谢：</h2>
<h3 id="lmpp"><a href="https://www.luogu.com.cn/user/160839">lmpp</a>大佬<strong>牺牲自己宝贵时间，为我没有脾气的耐心讲解。</strong></h3>
<h3 id="lmpp大佬的博客"><a href="https://www.luogu.com.cn/blog/160839/">lmpp大佬的博客</a>：墙裂建议进去康一康！</h3>
<h3 id="hcq大佬在本博客发表的第一时间就提出了许多宝贵建议">hcq大佬在本博客发表的第一时间就提出了许多宝贵建议！！</h3>
<h4 id="还有gmq-gbf同学感谢你们的鼓励与支持">还有gmq、gbf同学，感谢你们的鼓励与支持！！</h4>
<h4 id="did教给我知识真是太强了">did教给我知识真是太强了！！</h4>
<p>没有他们就没有这篇博客，我也会比现在蒻上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>倍。</p>
<hr>
<h2 id="提示">提示：</h2>
<p>本博客公开， <strong>但“例题部分”仅记录的是本人认为较有意义添加的题或者是本人的知识盲区。</strong> 我会以<strong>知识点为经，算法为纬</strong>，在知识点开头加入模板题并附有代码，有的时候会写一点小提示，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span>。</p>
<p>在我自己掌握特别不好的题目/知识点旁会加以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span> 的标记。</p>
<p><strong>所有题号以BSOJ为准。</strong></p>
<p>有什么错误纰漏的直接QQ+洛谷私信+讨论区留言，我真的超级需要您的反馈的qwq。</p>
<p>希望能您能从这份清单中找到您的一些知识漏洞并把他们补起来！</p>
<hr>
<h2 id="更新信息">更新信息</h2>
<p>2020.3.29 <strong>1.0版本</strong>，开始新的篇章。知识点记录至拓扑排序模板题。</p>
<p>2020.3.30 &amp;&amp; 2020.3.31 <strong>2.0版本</strong>，爆肝完所有知识点。</p>
<hr>
<h2 id="拓扑排序">拓扑排序：</h2>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1462">1462 拓扑排序</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>拓扑排序的基本知识：</strong></p>
<ul>
<li>
<p>在图论中，<strong>拓扑排序</strong>是一个<strong>有向无环图</strong>（DAG）的<strong>所有顶点的线性序列</strong>，该序列必须满足下面两个条件：</p>
<ol>
<li><strong>每个顶点出现且只出现一次。</strong></li>
<li><strong>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。</strong></li>
</ol>
</li>
<li>
<p><strong>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>1</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
</li>
<li>
<p>拓扑排序的操作方法：</p>
<ol>
<li>从DAG图中选择一个 <strong>没有前驱（即入度为零）</strong> 的顶点并输出。</li>
<li>从图中删除<strong>该顶点和所有以它为起点的有向边。</strong></li>
<li>重复1和2直到当前的DAG图为空或当前图不存在无前驱的顶点为止。<strong>后一种情况说明有向图中必然存在环。</strong></li>
</ol>
</li>
<li>
<p>通常，一个DAG图可以有<strong>一个或多个</strong>拓扑序列。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>1</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>：拓扑排序之所以只能针对于DAG图，就是因为它有<strong>每次取出入度为0的顶点</strong>的操作，如果有环，则环中的顶点不存在入度为0的点，无法进行拓扑排序。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>关于拓扑排序的应用</strong></p>
<p>拓扑排序一般很少有单独针对该知识点的题，但是在<strong>关键路径</strong>和平常的其他例题的辅助操作中却发挥着重要作用。所以掌握好拓扑排序是很重要的事情。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips3:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips3:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">3</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>本代码按字典序输出的部分：</strong></p>
<pre><code>int j=1; //从第一个点开始查找
while(j&lt;=n&amp;&amp;bein[j])
	j++; //统计入度为零的节点
//由于-1的bool值也视作真，所以可以标记为-1
if(j&gt;n) return 0; //如果统计的节点超出了范围n，说明这个图有环
sum[++top]=j; //拓扑序列答案数组统计新答案
</code></pre>
<pre><code>//本代码由邻接矩阵实现，按字典序输出，复杂度O(n^2)

#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 205
using namespace std;

int bein[maxn]; //bein[i]表示节点i的入度
int a[maxn][maxn]; //邻接矩阵存图
int sum[maxn],top; //拓扑序列答案数组
int n,m;

int TS()
{
	for(int i=1;i&lt;=n;i++)
	{
		int j=1; //从第一个点开始查找
		while(j&lt;=n&amp;&amp;bein[j])
			j++; //统计入度为零的节点
        //由于-1的bool值也视作真，所以可以标记为-1
		if(j&gt;n) return 0; //如果统计的节点超出了范围n，说明这个图有环
		sum[++top]=j; //拓扑序列答案数组统计新答案
		bein[j]=-1; //标记此点已经遍历
		for(int k=1;k&lt;=n;k++)
			if(a[j][k]) //如果j和k之间有边相连
				bein[k]--; //和j相关联的节点删除与j相连的边，即入度--
	}
	return 1; //如果遍历过程中没有返回过假值，则有解，返回真值
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		a[x][y]=1; //邻接矩阵储存单向边
		bein[y]++; //输入是从x到y的连线，所以是y的入度增加
	}
	if(TS()) //如果有解
		for(int i=1;i&lt;=n;i++)
			cout&lt;&lt;sum[i]&lt;&lt;&quot; &quot;; //则输出节点的答案数组
	else
		cout&lt;&lt;&quot;no solution&quot;&lt;&lt;endl; //无解输出&quot;no solution&quot;
	return 0;
}
</code></pre>
<hr>
<h2 id="最小生成树">最小生成树</h2>
<ul>
<li>
<p><strong>最小生成树</strong>：在一张带权的无向连通图中，<strong>各边权和为最小的一颗生成树</strong>即为最小生成树。</p>
<p>简单讲：找出<strong>连接所有点</strong>的<strong>最低成本路线</strong>。</p>
</li>
<li>
<p><strong>最小边原则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>2</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[2]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">2</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span></strong>：图中权值最小的边（如果唯一的话）一定在MST上。</p>
</li>
<li>
<p><strong>唯一性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>3</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[3]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">3</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span></strong>：一颗最小生成树上，如果各边的权都不相同，则最小生成树是唯一的。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>2</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[2]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">2</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>3</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[3]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">3</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>：这些补充的知识主要用于Prim算法的使用。</p>
<h3 id="kruskal算法">Kruskal算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Krudkal算法的基本知识：</strong></p>
<ul>
<li>
<p>Kruskal算法是一种贪心算法，它是<strong>将边按权值排序</strong>，每次从剩下的边集中<strong>选择权值最小且两个端点不在同一集合的边</strong>加入生成树中，反复操作，直到加入了（n-1）条边。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>4</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[4]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">4</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Kruskal的操作方法：</p>
<ol>
<li>按图中的边按权值从小到大快排。</li>
<li>按照权值从小到大依次选边，若当前选取的边加入后使生成树形成环，则舍弃当前边；否则标记当前边并计数。</li>
<li>重复2的操作，直到生成树中包含（n-1）条边为止；否则当遍历完所有的边后，都不能选取（n-1）条边，表示最小生成树不存在。</li>
</ol>
</li>
<li>
<p>算法的关键在于<strong>如何判定新加入的边会不会使图产生环</strong>，在这里使用<strong>并查集</strong>。如果新加入的边两个端点在并查集的同一个集合中，说明存在环，需要舍弃这条边；否则保留当前边，并合并涉及的两个集合。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mo>[</mo><mn>4</mn><mo>]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">^{[4]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">4</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span>：简单地说，就是将从小到大的边依次选入ans树中，若操作的两个两条边不属于同一集合（即不构成环），则加入ans树并累加值，反之则不作操作。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>并查集的基本操作：</strong></p>
<ol>
<li>找根节点：</li>
</ol>
<pre><code>int GetFather(int x)
{
	if(prt[x]==x) return x;
    return prt[x]=GetFather(prt[x]);
}
</code></pre>
<ol start="2">
<li>合并操作（一般可以直接写在主函数里）：</li>
</ol>
<pre><code>void Add(int x,int y)
{
	int f1=GetFather(x);
    int f2=GetFather(y);
    if(f1!=f2) prt[f1]=f2;
}
</code></pre>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1449">1449 最小生成树</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define maxn 40005
using namespace std;

int n,m;
int prt[maxn]; //prt[i]表示节点i的根节点
int ans=0; //最小生成树的总权值和
bool flag; //标记是否有解

struct Edge
{
	int x,y,v;
}a[maxn]; 
//x[i]代表a[i]这条边的起点
//y[i]代表a[i]这条边的终点
//v[i]代表a[i]这条边的权值

bool cmp(Edge x,Edge y) //结构体数组排序函数
{
	return x.v&lt;y.v;
}

int GetFather(int x) //并查集查找根节点，这里使用了状态压缩
{
	if(prt[x]==x) return x;
	prt[x]=GetFather(prt[x]); //压缩
	return prt[x];
}

void K()
{
	int f1,f2;
	int k=0;
	for(int i=1;i&lt;=m;i++)
	{
		f1=GetFather(a[i].x);
		f2=GetFather(a[i].y); //分别找出x，y所属的集合，即根节点
		if(f1!=f2) //如果不属于同一集合，即不会形成环，则合并两集合
		{
			ans+=a[i].v; //累加最小生成树的权和总值值
			prt[f1]=f2; //两集合合并
			k++; //总结点数累加
			if(k==n-1) //如果超过（n-1）条边，则停止遍历
				break;
		}
	}
	if(k&lt;n-1) //如果当遍历完所有的边后 都不能选取（n-1）条边 则表示最小生成树不存在
	{
		cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;
		flag=1; //标记没有最小生成树
		return ;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].v;
	for(int i=1;i&lt;=n;i++)
		prt[i]=i; //并查集初始化
	sort(a+1,a+m+1,cmp); //按边权从小到大排好，以便贪心操作
	K();
	if(!flag) //如果有最小生成树，则输出最小权值
		cout&lt;&lt;ans&lt;&lt;endl; 
	return 0;
}
</code></pre>
<hr>
<h3 id="prim算法">Prim算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Prim算法的操作方法：</strong></p>
<ul>
<li>
<p>将1号节点置入集合S中。</p>
</li>
<li>
<p>找到所有连接S中的节点和非S中的节点的边中权值最小的那一条，并标记这条边，同时将连接的非S中的节点加入S集合。</p>
</li>
<li>
<p>重复2步骤，知道左右节点在S中。</p>
</li>
</ul>
<p>（sorry，这里盗个did的图~）</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fR17UXKH-1585646967612)(https://s1.ax1x.com/2020/03/30/GusFwd.png)]</p>
<p>简单来说，就是S集合中的元素从一个根节点1开始，以<strong>一个集合整体出动</strong>的方式来扩展其他的点，以获取最小生成树。</p>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1449">1449 最小生成树</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define maxn 1005
using namespace std;

int a[maxn][maxn]; //元素数组
int d[maxn]; //d[i]表示不是生成树中点i到当前生成树中点的最小值
bool vis[maxn]; //vis[i]标记顶点i是否加入最小生成树中
int ans[maxn]; //答案数组

int n,m;
int sum;

int P(int x)
{
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=n;i++)
		d[i]=0x3f3f3f; //初始化
	d[x]=0; //第一个节点（即根节点）距离根节点（即自己）的距离为0
	int k;
	for(int i=1;i&lt;=n;i++)
	{
		int minn=0x3f3f3f; //统计最小边权
		for(int j=1;j&lt;=n;j++)
			if(!vis[j]&amp;&amp;d[j]&lt;minn) //如果节点j没有访问过且其边权小于当前最小边权
			{
				minn=d[j];
				k=j; //记录该节点			
			}
		vis[k]=1; //把该节点加入到集合中，设置状态为已访问
		sum+=d[k]; //累加总值
		for(int j=1;j&lt;=n;j++)
			if(!vis[j])
				d[j]=min(d[j],a[k][j]); //更新集合到每个点的最短距离
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			a[i][j]=0x3f3f3f; //初始化
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		a[x][y]=v;
		a[y][x]=v; //邻接数组建双边
	}
	P(1); //从1开始遍历
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr>
<h2 id="最短路径问题">最短路径问题</h2>
<ul>
<li>
<p><strong>最短路径</strong>：在一个有权图中连接给定两个顶点的权值和最小的路径。</p>
</li>
<li>
<p><strong>最短路树和最小生成树可以不一样</strong>。</p>
</li>
<li>
<p>一般有两类最短路问题：</p>
<ol>
<li>SSSP（单源最短路）：求<strong>给定起点S到其他所有点</strong>的最短路，常见算法有<strong>Dijkstra算法、SPFA算法</strong>等。</li>
<li>APSP（多源最短路）：求<strong>任意两对顶点</strong>之间的最短路，常见算法有Floyed算法。</li>
</ol>
</li>
</ul>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>三角形性质</strong>：</p>
<p>设源点S到点x、y的最短路径长度为d[x]、d[y]。x与y之间的距离是g[x][y]，则有下面的“三角形定理”：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x]+g[x][y]&gt;=d[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>松弛</strong>：</p>
<p>若在处理过程中，有两点x、y出现不符合“三角形定理”，则可“松弛一下”：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>f</mi><mo>(</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>&lt;</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">if(d[x]+g[x][y]&lt;d[y]) d[y]=d[x]+g[x][y];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips3:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips3:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">3</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Dijkstra算法的操作方法</strong>：</p>
<ul>
<li>
<p>初始化d[v0]=0，源点到其他点的距离值d[i]=inf。</p>
</li>
<li>
<p>经过n次如下步骤操作，最后得到v0到n个顶点的最短距离：</p>
<ol>
<li>选择一个未标记的点k并且d[k]的值是当前最小的。</li>
<li>标记点k，即vis[k]=1.</li>
<li>以k为中间点，修改源点v0到其他未标记点j的距离值d[j]。</li>
</ol>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips4:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips4:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">4</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>个人小议Dijkstra算法与Prim算法的不同</strong>：</p>
<ul>
<li>
<p>目的上，Prim试求最小生成树，Dijkstra试求最短路</p>
</li>
<li>
<p>距离上，Prim是让整个集合看距离，而这个集合是一堆边<br>
Dijkstra是从原点开始更新距离，然后点连点更新距离；</p>
</li>
<li>
<p>连点上，Prim是一个集合（边）连所有点<br>
Dijkstra是一个点只能连直接与自己相关联的点，在开始连接新的点的时候，从最小的点开始继续访问</p>
</li>
<li>
<p>Dijkstra之所以选当前最小的点开始继续连点是因为最小的点可以有期望让到其他的点的边权尽量小</p>
</li>
<li>
<p>Prim算法数组里存的是点到集合的距离<br>
Dijkstra算法数组里存的是所有点到总的原点1的距离</p>
</li>
</ul>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1428">1428 最短路径问题</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

#define maxn 1005
using namespace std;

double a[maxn]; //a[i]表示不是生成树中点i到源点的最小值
double g[maxn][maxn]; //邻接数组存边
int prt[maxn]; //记录自己的值是从哪个节点来的，即为相对的父亲节点
bool vis[maxn]; //标记是否访问过
int s,t; //起点和终点
int n,m;

struct Node
{
	int x,y;
}q[maxn]; //储存坐标

double len(Node a,Node b) //通过x、y坐标计算边的长度
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

void D()
{
	for(int i=1;i&lt;=n;i++)
		a[i]=999999.9; //初始化
	int k;
	a[s]=0; //第一个节点（即根节点）距离根节点（即自己）的距离为0
	prt[s]=0; //第一个节点的父亲定义为0
	for(int i=1;i&lt;=n;i++)
	{
		double minn=999999.9; //找最小边权
		for(int j=1;j&lt;=n;j++)
			if(!vis[j]) //如果未访问过
				if(a[j]&lt;minn) //且此边权小于当前最小边权
				{
					minn=a[j]; //则更新最小边权
					k=j; //记录此节点
				}
		vis[k]=1; //访问该节点
		for(int j=1;j&lt;=n;j++)
			if(g[k][j]&gt;0&amp;&amp;!vis[j]) //更新与该节点有连接的点的边权值
				if(a[k]+g[k][j]&lt;a[j]) //松弛操作
				{
					a[j]=a[k]+g[k][j];
					prt[j]=k; //记录更新它的值的节点
				}
	}
}

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		q[i].x=x;
		q[i].y=y; //记录坐标
	}
	cin&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		double v=len(q[x],q[y]); //计算边权
		g[x][y]=v;
		g[y][x]=v; //邻接矩阵建双边
	}
	cin&gt;&gt;s&gt;&gt;t;
	D();
	printf(&quot;%.2f&quot;,a[t]); //直接输出节点t距离源点s的距离
	return 0;
}
</code></pre>
<h3 id="floyed算法">Floyed算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Floyed算法的基本知识</strong>：</p>
<ul>
<li>
<p>Floyed算法是DP思想。</p>
</li>
<li>
<p>Floyed算法可以求出每队点之间的最短距离，它对于图的要求是，可以是无向图和有向图，边权可正可负，唯一的要求是不能有负环。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Floyed算法的基本思想</strong>：</p>
<ul>
<li>
<p>初始化f[i][j]=w[i][j]，从小到大枚举k，对每对节点（u，v），检查它们的最短路值。</p>
</li>
<li>
<p>f[i][j]表示该状态下（即路径中间只允许经过节点i~k的情况下，k递增，定义在循环内），i到j的最短路距离<br>
其状态转移方程为：</p>
<ol>
<li><strong>最短路经过点k</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][k]+f[k][j];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></li>
<li><strong>最短路不经过点k</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>（这里等号右边的f[i][j]实为上一阶段的f[i][j]）</li>
</ol>
</li>
</ul>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1584">1584 银行设置</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips3:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips3:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">3</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>初始化</strong>：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">f[i][j]=0,i==j;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>i</mi><mi>n</mi><mi>f</mi><mo separator="true">,</mo><mi>i</mi><mo>!</mo><mo>=</mo><mi>j</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">f[i][j]=inf,i!=j;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">;</span></span></span></span></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
#define inf 0x3f3f3f
using namespace std;

int f[maxn][maxn]; //操作数组，f[i][j]表示该状态下（即路径中间只允许经过节点i~k的情况下，k递增，定义在循环内），i到j的最短路距离
int n,m;
int a[maxn][maxn]; //

void Floyed()
{
	for(int k=1;k&lt;=n;k++) //枚举中间点
		for(int i=1;i&lt;=n;i++) //枚举起点
			for(int j=1;j&lt;=n;j++) //枚举终点
				if(f[i][k]!=inf&amp;&amp;f[k][j]!=inf)
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(i==j) f[i][j]=0;
			else f[i][j]=inf; //初始化，自己到自己的最短路设置为0,
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		f[x][y]=f[y][x]=v; //邻接矩阵建边
	}
	Floyed();
	for(int k=1;k&lt;=n;k++)
		for(int i=1;i&lt;n;i++)
			for(int j=i+1;j&lt;=n;j++) //为了避免重复从i+1开始遍历另一种点
				a[i][j]+=min(f[i][k],f[k][j]); //由于设置两个银行，所以取f[i][k]与f[k][j]的最小值
	int ans=inf;
	int ans1,ans2;
	for(int i=1;i&lt;n;i++)
		for(int j=i+1;j&lt;=n;j++)
			if(a[i][j]&lt;ans) //取最小值
			{
				ans=a[i][j];
				ans1=i; //记录节点序号
				ans2=j; 
			}
	cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl;
	return 0;
}
</code></pre>
<h3 id="spfa算法">SPFA算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>SPFA算法的基本知识</strong>：（摘录自did的PPT，归纳的很好就直接搬运了qwq）</p>
<ul>
<li>
<p>设立一个先进先出的队列用来保存待优化的节点，优化时每次取出队首节点u，并且**用u点当前的最短路径估计值对u点所指向的节点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。**这样不断从队列中取出节点来进行松弛操作，直至队列空为止。这个算法保证只要最短路径存在，SPFA算法必定能求出最小值。</p>
</li>
<li>
<p>SPFA算法同样可以判断负环，如果某个点弹出队列的次数超过n-1次，则存在负环。对于存在负环的图，无法计算单源最短路径。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>SPFA算法的基本操作</strong>：（摘录自did的PPT，归纳的很好就直接搬运了qwq）</p>
<ul>
<li>S为源点，vst[]记录点是否在队列中，距离值为dist[]</li>
</ul>
<ol>
<li>
<p>初始化，源点的距离dist[S]=0，其它点的距离设为INF，新建一个队列，将源点S入队，标记源点S已经在队列中。</p>
</li>
<li>
<p>从队首取出一个点i，标记i已经出队，接着对和i点有边相连的j点进行松弛操作，如果松弛成功，则对i入队的次数进行检查，如果大于等于n，说明出现负环，算法结束；否则改进dist[j]的值，再检查j是否在队列中，如果不在，就将j点加入队尾。</p>
</li>
<li>
<p>重复执行步骤2，直到队列为空。</p>
</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips3:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips3:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">3</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>常见疑惑</strong>：</p>
<ol>
<li>
<p>Q：SPFA算法的复杂度？<br>
A：玄学，平均复杂度为O(2E)，其大时可以极大，小时可以极小。</p>
</li>
<li>
<p>Q：在算法中，如果后出队的点可以使前面的点更忧，而那个点的值改变了，它的子节点的值也会改变。这个时候需要入队吗？<br>
A：需要，而且不用担心vis[i]=1的问题。当我们出队以后vis[i]会归零的。</p>
</li>
</ol>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1580">1580 最短路(Spfa)2885</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;

#define maxn 500010
using namespace std;

queue &lt;int&gt; q;

int vis[maxn]; //vis[i[]表示点i是否在队中
int d[maxn]; //d[i[]表示点i距离源点的最短路

struct Edge
{
	int to,next,v;
}a[maxn&lt;&lt;1]; //前向星结构体数组


int head[maxn],cnt;
//int used[maxn]; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
int n,m;

void AddEdge(int x,int y,int v) //前向星建边操作
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	head[x]=cnt;
	a[cnt].v=v;
}

int Spfa(int x)
{
	for(int i=1;i&lt;=n;i++)
		d[i]=0x3f3f3f3f;
//	memset(vis,0,sizeof(vis));
	q.push(x);
	vis[x]=1;
	d[x]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0; //因为点u已出队，释放点u
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]&gt;d[u]+a[i].v)
			{
//				used[v]++;
//				if(used[v]&gt;n) return 0; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
				d[v]=d[u]+a[i].v; //更新边权
				if(!vis[v]) //如果点v可以遍历（可以添加）
				{
					vis[v]=1; //标记已在队中
					q.push(v); //则入队
				}
			}
		}
	}
//	return 1; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		AddEdge(x,y,v);
		AddEdge(y,x,v); //前向星建双边
	}
//	if(Spfa(1))
//		cout&lt;&lt;d[n]&lt;&lt;endl; //这句代码可用于判断有无解时使用，本题保证有解，所以不需要了
	Spfa(1);
	cout&lt;&lt;d[n]&lt;&lt;endl; //直接输出
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h2 id="有向图的连通性">有向图的连通性</h2>
<p><strong>关于有向图的相关概念</strong>：</p>
<ul>
<li>
<p><strong>强连通图</strong>：有向图中，如果对每一对Vi,Vj(Vi,Vj属于V，Vi不等于Vj)。从Vi到Vj和从Vj到 Vi都存在路径，则称G是强连通图。<br>
简单来说，即：<strong>如果一张有向图中任意两点有路径可以互相到达，则称这张图是强连通图</strong></p>
</li>
<li>
<p>**强连通分量：**有向图的极大强连通子图叫强连通分量。</p>
</li>
<li>
<p>**最关键通用部分：**强连通分量一定是图的深搜树的一个子树。</p>
</li>
</ul>
<h3 id="tarjan算法">Tarjan算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips1:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips1:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">1</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Tarjan算法的基本知识：</strong>（摘录自did的PPT，归纳的很好就直接搬运了qwq）</p>
<ul>
<li>
<p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p>
</li>
<li>
<p>定义DFN(u)为节点u搜索的次序编号(时间戳)，Low (u)为u或u的子树能够追溯到的最早的栈中节点的次序号。</p>
</li>
<li>
<p>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips2:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips2:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">2</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>Tarjan算法的基本操作</strong>：</p>
<ul>
<li>
<p>找一个没有被访问过的节点u；否则，算法结束；(图不连通)</p>
</li>
<li>
<p>初始化dfn[u]和low[u]<br>
对于u所有的邻接顶点v：</p>
<ol>
<li>如果没有访问过，则转到步骤(2)，同时维护low[u]；</li>
<li>如果访问过，但没有删除，维护low[u]；</li>
</ol>
</li>
<li>
<p>如果low[u]==dfn[u]，那么输出相应的强连通分量。</p>
</li>
</ul>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1572">1572 消息的传递2269</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;

#define maxn 1005
#define inf 0x7fffffff/2
using namespace std;

stack &lt;int&gt; q;
int in[maxn][maxn]; //入度
int DFN[maxn],LOW[maxn]; 
int from[maxn]; //找所属 
bool flag[maxn]; //标记数组
int bein[maxn]; //强连通分量入度 

int cnt;
int t; //时间戳 
int y;
int n;

void Tarjan(int x)
{
	DFN[x]=LOW[x]=++t; //给x按照访问顺序的先后标号为t，给LOW[x]赋初始值
	q.push(x); //x点进栈
	flag[x]=1; //这个用来判断横叉边
	for(int i=1;i&lt;=n;i++)
		if(in[x][i]) //边xi没有被标记过
			if(!DFN[i]) //i未被标记过
			{
				Tarjan(i); //xi是父子边，递归访问
				LOW[x]=min(LOW[i],LOW[x]);
			}
			else if(flag[i])
				LOW[x]=min(DFN[i],LOW[x]); //xi是返祖边
	if(LOW[x]==DFN[x]) //统计块数
	{
		cnt++;
		while(y!=x)
		{
			y=q.top();
			q.pop();
			from[y]=cnt; //定义当前快的编号为cnt
			flag[y]=0; //释放标记
		}
	}
}

int main()
{
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			cin&gt;&gt;in[i][j]; //邻接矩阵存储边关系
	for(int i=1;i&lt;=n;i++)
		if(!DFN[i]) Tarjan(i); //如果没有遍历过，则遍历一遍
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(in[i][j]&amp;&amp;from[i]!=from[j])
				bein[from[j]]++; //统计每个块的入度
	int sum=0; //统计需要传播给多少个人
	for(int i=1;i&lt;=cnt;i++)
		if(!bein[i])
			sum++; //如果有块入度为零，代表必须单独传播信息，所以sum++
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h3 id="无向图的连通性">无向图的连通性</h3>
<p><strong>关于无向图的相关概念</strong>：</p>
<ul>
<li>
<p><strong>割点</strong>：</p>
<ol>
<li>
<p>定义：<br>
在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点及与该顶点相关联的边时, 也不破坏图的连通性。<strong>如果一个图不是双连通的，那么，将其删除后图将不再连通的那些顶点称为割点。</strong><br>
简言之：<strong>G是连通图，u∈V(G)，G–u不再连通，则称u是G的割点。</strong></p>
</li>
<li>
<p>求割点的算法：<br>
我们通过DFS把无向图定向成有向图，定义每个顶点两个参数：<br>
① dfn[u]表示顶点u访问的先后顺序。<br>
② lowlink[u]表示沿u出发的有向轨能够到达的点v中，dfn[v]值的最小值 (经过返祖边后则停止)</p>
</li>
<li>
<p>三个定理<br>
【定理1】：DFS中，e=ab是返祖边，那么要么a是b的祖先，要么a是b的后代子孙。<br>
【定理2】：DFS中，e=uv是父子边，且dfn[u]&gt;1，lowlink[v]≥dfn[u]，则u是割点。<br>
【定理3】：DFS的根r是割点的充要条件是：至少有2条以r为尾(从r出发)的父子边。</p>
</li>
<li>
<p>求割点的算法：</p>
</li>
</ol>
<pre><code>void DFS(int u)
{ 
	sign++;
	dfn[u]=sign; //给u按照访问顺序的先后标号为sign
	lowlink[u]=sign; //给lowlink[u]赋初始值
	for(int v=1;v&lt;=n;v++) //寻找一个u的相邻节点v
		if(MAP[u][v]&amp;&amp;prt[u]!=v) // u→v有边相连且不是回边
		{
      	if(dfn[v]==0) //v未被访问
			{
          	prt[v]=u; //则u是v的父亲
				DFS(v); //uv是父子边，递归访问v
				lowlink[u]=min(lowlink[u],lowlink[v]);//所有儿子中最小值
				if(lowlink[v]&gt;=dfn[u])
				{
              	if(dfn[u]==1)
                  {
                  	son++;
                      if(son&gt;=2) cout&lt;&lt;u&lt;&lt;endl;
                  }//根
				else cout&lt;&lt;u&lt;&lt;endl;//u是割点
		        }
	       }
         else lowlink[u]= min(lowlink[u],dfn[v]);
	   //若已访问则访问时间一定早于u，uv是返祖边
    }
}
</code></pre>
</li>
<li>
<p><strong>割边</strong>：</p>
<ol>
<li>定义：<br>
G是连通图，e∈E(G)，G-e不再连通，则称e是G的割边，亦称做桥。</li>
</ol>
<p>2.求割边的算法<br>
与割点类似的，我们定义low和dfn。父子边e=u→v ，当且仅当low[v]&gt;dfn[u]的时候，e是割边。</p>
<p>3.求割边的参考代码：</p>
<pre><code>void DFS(int u)
{
   sign++;
   dfn[u]=sign; //给u按照访问顺序的先后标号为sign
   lowlink[u]=sign; //给lowlink[u]赋初始值
   for(寻找一个u的相邻节点v)
      if(边uv没有被标记过)
      {
         标记边uv;
         给边定向u→v;
         if(v未被标记过)
         {
            DFS(v); //uv是父子边，递归访问
            lowlink[u]=min(lowlink[u],lowlink[v]);
            if(lowlink[v]&gt;dfn[u])uv是割边
         }
         else lowlink[u]=min(lowlink[u],dfn[v]);//uv是返祖边
      }
}
</code></pre>
<ol start="4">
<li>割点与割边<br>
<strong>两个割点之间的边不是割边，割边的两端点不是割点。</strong></li>
</ol>
</li>
<li>
<p>块<br>
1.定义：<br>
没有割点的图叫2-连通图，亦称做块。把每个块收缩成一个点，就得到一棵树，它的边就是桥。</p>
<p>2.求块的算法：<br>
在求割点的算法中，当结点u的所有邻边都被访问过之后，如果存lowlink[u]=dfn[u]，我们把u下方的整块和u导出作为图中的一个块。<br>
这里需要用一个<strong>栈</strong>来表示哪些元素是u代表的块。</p>
</li>
</ul>
<h2 id="关键路径">关键路径</h2>
<p><strong>关于关键路径的相关概念</strong>：</p>
<p>定义：在一个给定的有向无环图中，求从<strong>开始顶点到结束顶点的最长路径</strong>（路径上的<br>
权值和）叫关键路径。</p>
<p>算法步骤：</p>
<ol>
<li>读入数据，建立有向图</li>
<li>对DAG进行拓扑排序，得到拓扑序列</li>
<li><strong>以拓扑序列为阶段，用DP求关键路径</strong></li>
</ol>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1570">1570 工厂的烦恼</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

#define maxn 1005
#define inf 0x7fffffff/2
using namespace std;

int bein[maxn];
int a[maxn];
int f[maxn]; //f[a[i]]表示到达顶点a[i]的最长路径
int in[maxn][maxn];
int n,m;

void Topsort() //拓扑排序，不解释，详细内容本博客开头有介绍
{
	int j;
	for(int i=1;i&lt;=n;i++)
	{
		j=1;
		while((j&lt;=n)&amp;&amp;(bein[j]!=0)) j++;
		bein[j]=inf;
		a[i]=j;
		for(int k=1;k&lt;=n;k++)
			if(in[j][k]) bein[k]--;
	}
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,v;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
		in[x][y]=v;
		bein[y]++;
	} //配合拓扑排序及符合题意的输入，不解释
	Topsort();
	for(int i=2;i&lt;=n;i++) //以拓扑序列为阶段
		for(int j=1;j&lt;=i-1;j++)
			f[a[i]]=max(in[a[j]][a[i]]+f[a[j]],f[a[i]]); //DP求关键路径	
	cout&lt;&lt;f[a[n]]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="Red"><menclose mathbackground="Yellow"><mtext>！</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{Red}\colorbox{Yellow}{！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:Red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:Red;height:1.2833299999999999em;background-color:Yellow;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:Red;"><span class="mord cjk_fallback" style="color:Red;">！</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<h2 id="差分约束系统">差分约束系统</h2>
<p>像这样一类问题：给定一组不等式x[i]-x[j]&lt;=c<a href="%E6%88%96x%5Bi%5D-x%5Bj%5D%3E=c%5Bk%5D">k</a>，需要求出满足所有不等式的一组解(x[1],x[2],…,x[n])。</p>
<p>这类问题实际上是线性规划的一类简单问题。<strong>通常可以用系数矩阵表示为Ax&lt;=C(或Ax&gt;=C),其中系数矩阵A的每一行里有一个1和一个-1，其余元素都为0。若A 为m<em>n的矩阵，则x为n</em>1的矩阵，C为m*1的矩阵，对应有m个不等式，n个未知数，即该系统为一个有n个未知数、m个约束条件的系统。这就是差分约束系统。</strong></p>
<p>如果一组解(x[1],x[2],….,x[n])满足给定的不等式组，那么(x[1]+a,x[2]+a,….,x[n]+a)也能够满足，**所以这类问题的解不唯一。**实际问题中通常对输出的解有一些特别的要求。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CornflowerBlue"><menclose mathbackground="Lavender"><mtext mathvariant="fraktur">tips:</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\mathfrak\color{CornflowerBlue}\colorbox{Lavender}{tips:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48047em;vertical-align:-0.48906em;"></span><span class="mord" style="color:CornflowerBlue;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914099999999999em;"><span style="top:-2.99141em;"><span class="pstrut" style="height:3.48047em;"></span><span class="stretchy colorbox" style="color:CornflowerBlue;height:1.48047em;background-color:Lavender;"></span></span><span style="top:-3.48047em;"><span class="pstrut" style="height:3.48047em;"></span><span class="mord boxpad" style="color:CornflowerBlue;"><span class="mord mathfrak" style="color:CornflowerBlue;">t</span><span class="mord mathfrak" style="color:CornflowerBlue;">i</span><span class="mord mathfrak" style="color:CornflowerBlue;">p</span><span class="mord mathfrak" style="color:CornflowerBlue;">s</span><span class="mord mathfrak" style="color:CornflowerBlue;">:</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48906em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>自己的一些零碎总结</strong>：</p>
<ul>
<li>
<p>差分约束系统将题目中的约束条件不等式（即d[x]+w(x,t)&gt;=d[y]或d[x]+w(x,t)&lt;=d[y]之类）转换为图论的单源最短路问题。</p>
</li>
<li>
<p>当不等式是 <strong>d[x]+w(x,t)&gt;=d[y]</strong> 时，求最短路；当题目不等式是 <strong>d[x]+w(x,t)&lt;=d[y]</strong> 时，求最长路。</p>
</li>
<li>
<p>有负权回路的有向图不存在最短路径，即无解。</p>
</li>
<li>
<p>注意建边时是<strong>j到i建边</strong>，其原因是不等式。</p>
</li>
</ul>
<p><a href="https://oj.bashu.com.cn/pub/problempage.php?problem_id=1595">1595 工程规划1252</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;

#define maxn 5005
using namespace std;

struct sj {
	int to,next,w;
} a[maxn&lt;&lt;1]; //前向星结构体数组

int kk,inf,n,m,cnt[maxn],flag;
int head[maxn],size;
int v[maxn],dis[maxn];
int fag;

void AddEdge(int x,int y,int z) {
	a[++size].to=y;
	a[size].next=head[x];
	head[x]=size;
	a[size].w=z;
} //前向星建边操作

void SPFA(int s) { //普通SPFA跑一遍，不解释，详细介绍前面有
	queue&lt;int&gt;q;
	q.push(s);
	dis[s]=0;
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		cnt[x]++;
		if(cnt[x]&gt;n) {
			cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;
			fag=1;
			return ;
		}
		for(int i=head[x]; i; i=a[i].next) {
			int tt=a[i].to;
			if(dis[tt]&gt;dis[x]+a[i].w) {
				dis[tt]=dis[x]+a[i].w;
				if(!v[tt])
					q.push(tt),v[tt]=1;
			}
		}
		v[x]=0;
	}
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1; i&lt;=m; i++) {
		int x,y,z;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		AddEdge(y,x,z); //一定注意，是y向x连边
	}
	memset(dis,127,sizeof(dis));
	for(int i=1; i&lt;=n; i++) { //构建虚拟超级源点，所有边都连上
		AddEdge(0,i,0);
	}
	SPFA(0);
	if(!fag) {
		for(int i=1; i&lt;=n; i++)
			kk=min(kk,dis[i]); //寻找最小值
		for(int i=1; i&lt;=n; i++)
			printf(&quot;%d\n&quot;,dis[i]-kk);
	}
	return 0;
}
</code></pre>
<hr>
<h2 id="后记-by-2020331">后记 by 2020.3.31</h2>
<p>由于时间仓促，后面的代码等内容可能没有前面详尽。当然，本蒟蒻在写作过程中肯定有不对之处，还希望大佬们广泛地提出问题，以便我和大家更好的知识掌握。</p>
<p>感谢您的认真观看！</p>
]]></content>
    </entry>
</feed>